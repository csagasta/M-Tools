ZZUTXTE1	;UNIT TESTS FOR ECLIPSE EDITOR ;01/16/12  12:14
	;;7.3;TOOLKIT;**101**;
	D EN^XTMUNIT($T(+0))
	Q
	;
COMMACNT	;
	D CHKEQ^XTMUNIT($$COMMACNT^XTECGLO("^TMP(1,3)"),2,"BAD RETURN FOR SIMPLE COMMA COUNT")
	Q
	;
QUOTES	; handle quoted strings with commas correctly
	N ZZUTGLOB,ZZUTARR,ZZUTVAL,ZZUTINPT
	S ZZUTGLOB=$NA(^TMP("ZZUTXTE1",$J)) K @ZZUTGLOB
	S @ZZUTGLOB@("VALUES","XTLOGSEQ")=0
	S @ZZUTGLOB@("VAR","^TMP(""XTDEBUG"",5320,""LVL"",4)")="A"
	S @ZZUTGLOB@("VAR","^TMP(""XTDEBUG"",5320,""LVL"",5)")="B"
	S @ZZUTGLOB@("VAR","XTDEBDUZ")="C"
	S ZZUTARR(1,1)="""ZZUTXTE1""",ZZUTARR(2,1)=$J
	S ZZUTINPT=$NA(@ZZUTGLOB@("VAR","^TMP(""XTDEBUG"",5320,""LVL"",4)"))
	S ZZUTVAL=$$CHKRANGE^XTECGLO(ZZUTINPT,0,.ZZUTARR)
	D CHKEQ^XTMUNIT(ZZUTVAL,ZZUTINPT,"BAD RETURN FOR QUOTES")
	K @ZZUTGLOB
	Q
	;
CHKRANG2	;
	N GLOBLOC,I,ARRAY,ENDGLOB,GLOBAL
	S GLOBLOC=$NA(^TMP("ZZUTXTE1_TEST",$J)) K @GLOBLOC
	F I=1:1:12 S @GLOBLOC@(I)=I
	F I=$A("A"):1:$A("F") S @GLOBLOC@(""""_$C(I)_"""")=$C(I)
	S ^TMP("ZZUTXTF",$J)="",ENDGLOB=$NA(^TMP("ZZUTXTF"))
	; Fixed start ^TMP("ZZUTXTE1_TEST",$J,4,
	S ARRAY(1,1)="""ZZUTXTE1_TEST""",ARRAY(2,1)=$J,ARRAY(3,1)=4
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(1)),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@(4)),"BAD RETURN BELOW FIXED VALUE")
	S GLOBAL=$$CHKRANGE^XTECGLO(GLOBAL,0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@(4)),"BAD RETURN FIXED VALUE ON ENTRY")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(5)),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,ENDGLOB,"BAD RETURN ABOVE FIXED VALUE ON ENTRY NO MAXCOMMA")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(5)),3,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,ENDGLOB,"BAD RETURN ABOVE FIXED VALUE ON ENTRY WITH MAXCOMMA")
	; Fixed dual range ^TMP("ZZUTXTE1_TEST",$J,4:6 9:11,
	S ARRAY(3,1,1)=6,ARRAY(3,2)=9,ARRAY(3,2,1)=11
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(1)),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@(4)),"BAD RETURN FOR VALUE BELOW FIRST RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(4)),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@(4)),"BAD RETURN FOR FIRST VALUE IN RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(5)),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@(5)),"BAD RETURN FOR CORRECT VALUE IN RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(6)),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@(6)),"BAD RETURN FOR TOP VALUE IN RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(7)),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@(9)),"BAD RETURN FOR VALUE BELOW FIRST RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(9)),3,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@(9)),"BAD RETURN FOR FIRST VALUE IN SECOND RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(9)),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@(9)),"BAD RETURN FOR CORRECT VALUE IN RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(11)),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@(11)),"BAD RETURN FIXED VALUE ON ENTRY")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(12)),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,ENDGLOB,"BAD RETURN ABOVE FIXED VALUE SECOND RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(11,0)),3,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,ENDGLOB,"BAD RETURN ABOVE FIXED VALUE SECOND RANGE EXCEEDING MAXCOMMA")
	; Fixed range ^TMP("ZZUTXTE1_TEST",$J,"B":"D",
	K ARRAY(3) S ARRAY(3,1)="""B""",ARRAY(3,1,1)="""D"""
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@(1)),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@("B")),"BAD RETURN FOR VALUE BELOW FIRST RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@("A")),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@("B")),"BAD RETURN FOR FIRST VALUE IN RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@("B")),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@("B")),"BAD RETURN FOR CORRECT VALUE IN RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@("D")),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,$NA(@GLOBLOC@("D")),"BAD RETURN FOR TOP VALUE IN RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@("E")),0,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,ENDGLOB,"BAD RETURN FOR VALUE BELOW FIRST RANGE")
	S GLOBAL=$$CHKRANGE^XTECGLO($NA(@GLOBLOC@("D",0)),3,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,"","BAD RETURN FOR VALUE AT END OF RANGE EXCEEDING COMMAS")
	K @GLOBLOC
	Q
	;
FOLLOWS	;
	N TESTVAL,BASEVAL
	; FIRST ARGUMENT IS VALUE BEING TESTED VS SECOND ARGUMENT
	D CHKTF^XTMUNIT($$FOLLOWS^XTECGLO(10,5),"INCORRECT FOR NUMERIC TEST")
	D CHKTF^XTMUNIT('$$FOLLOWS^XTECGLO(5,10),"INCORRECT FOR FALSE NUMERIC TEST")
	;
	D CHKTF^XTMUNIT($$FOLLOWS^XTECGLO("A",5),"INCORRECT FOR ALPHA VS NUMERIC TEST")
	D CHKTF^XTMUNIT('$$FOLLOWS^XTECGLO(5,"A"),"INCORRECT FOR FALSE ALPHA VS NUMERIC")
	;
	D CHKTF^XTMUNIT($$FOLLOWS^XTECGLO("C","A"),"INCORRECT FOR ALHPA VS ALPHA")
	D CHKTF^XTMUNIT('$$FOLLOWS^XTECGLO("A","C"),"INCORRECT FOR FALSE ALPHA VS ALPHA")
	Q
	;
GETARRAY	;
	N GLOSTART,GLOBAL,MAXCOMMA,ARRAY
	S GLOBAL="^DD(,.01,0)"
	S GLOSTART=$$GETLIMIT^XTECGLO(GLOBAL,.MAXCOMMA,.ARRAY)
	D CHKEQ^XTMUNIT(GLOSTART,"^DD(","BAD GLOSTART")
	D CHKEQ^XTMUNIT(MAXCOMMA,3,"BAD MAXCOMMA")
	D CHKEQ^XTMUNIT(ARRAY(2,1),.01,"BAD SECOND NODE")
	D CHKEQ^XTMUNIT(ARRAY(3,1),0,"BAD THIRD NODE")
	;
	K ARRAY
	S GLOBAL="^XTV(8992,,""A"":""B"",0:4"
	S GLOSTART=$$GETLIMIT^XTECGLO(GLOBAL,.MAXCOMMA,.ARRAY)
	D CHKEQ^XTMUNIT(GLOSTART,"^XTV(","BAD GLOSTART WITH FIRST NODE")
	D CHKEQ^XTMUNIT(MAXCOMMA,0,"BAD MAXCOMMA NO CLOSING PAREN")
	D CHKEQ^XTMUNIT(ARRAY(1,1),8992,"FIRST LEVEL ARRAY BAD")
	D CHKEQ^XTMUNIT(ARRAY(3,1),"""A""","BAD START OF ALPHA RANGE")
	D CHKEQ^XTMUNIT(ARRAY(3,1,1),"""B""","BAD END OF ALPHA RANGE")
	D CHKEQ^XTMUNIT(ARRAY(4,1),0,"BAD START OF NUMERIC RANGE")
	D CHKEQ^XTMUNIT(ARRAY(4,1,1),4,"BAD END OF NUMERIC RANGE")
	Q
	;
CHKRANGE	;
	N GLOSTART,GLOBAL,ARRAY,MAXCOMMA
	S GLOSTART="^DD",MAXCOMMA=0
	S GLOBAL=$Q(@GLOSTART)
	S ARRAY(1,1)="",ARRAY(2,1)=.01,ARRAY(3,1)=0
	S GLOBAL=$$CHKRANGE^XTECGLO(GLOBAL,MAXCOMMA,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,"^DD(0,.01)","BAD GLOBAL RETURNED FOR 0")
	;
	S GLOBAL=$Q(@GLOBAL)
	S GLOBAL=$$CHKRANGE^XTECGLO(GLOBAL,MAXCOMMA,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,"^DD(0,.01,0)","BAD GLOBAL RETURNED SECOND PASS")
	;
	S GLOBAL=$Q(@GLOBAL)
	S GLOBAL=$$CHKRANGE^XTECGLO(GLOBAL,MAXCOMMA,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,"^DD(0,.1)","BAD GLOBAL RETURNED THIRD PASS")
	;
	S GLOBAL=$Q(@GLOBAL)
	S GLOBAL=$$CHKRANGE^XTECGLO(GLOBAL,MAXCOMMA,.ARRAY)
	D CHKEQ^XTMUNIT(GLOBAL,"^DD(.001)","BAD GLOBAL RETURNED FOURTH PASS")
	Q
	;
LOADROU	; LOAD A ROUTINE
	N ROU,TMP,VAL S ROU="XQALERT"
	K TMP
	S VAL=$$LOADROU^XTECROU(ROU,"TMP")
	D CHKEQ^XTMUNIT(1,VAL,"INVALID RETURN FROM LOADROU")
	D CHKTF^XTMUNIT($G(TMP(1,0))["XQALERT","BAD FIRST LINE RETURNED")
	Q
	;
ROUSIZE	;get total and comment size of routine
	N VAL
	S VAL=$$GETSIZE^XTECROU("XTECROU")
	D CHKEQ^XTMUNIT(8521,+VAL,"TOTAL SIZE IS INCORRECT")
	D CHKEQ^XTMUNIT(2252,$P(VAL,U,2),"COMMENT SIZE IS INCORRECT")
	Q
	;
XTROU	;
	;;ZZUTXTG1;OTHER GLOBAL LIST TESTS
XTENT	;
	;;GETARRAY;GET NODE ARRAY
	;;CHKRANGE;CHECK OR MOVE TO LIMITS
	;;FOLLOWS;CHECK IF TEST VARIABLE FOLLOWS ANOTHER
	;;CHKRANG2;VARIOUS RANGE CHECKS
	;;QUOTES;handle commas, etc. inside quotes
	;;COMMACNT;NUMBER OF COMMAS, ACCOUNTING FOR QUOTES
	;;LOADROU;LOAD A ROUTINE
	;;ROUSIZE;get routine size and comment size
