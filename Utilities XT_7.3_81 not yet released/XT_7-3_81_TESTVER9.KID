
TEST
KIDS Distribution saved on Jan 05, 2012@16:09:40
Test version 9 of patch XT*7.3*81 Programmer Utilities and M-Unit
**KIDS**:XT*7.3*81^

**INSTALL NAME**
XT*7.3*81
"BLD",790,0)
XT*7.3*81^TOOLKIT^0^3120105^y^^
"BLD",790,1,0)
^^3^3^3080606^^^^
"BLD",790,1,1,0)
XT*7.3*81
"BLD",790,1,2,0)
 
"BLD",790,1,3,0)
See the Patch Module for description.
"BLD",790,4,0)
^9.64PA^8992.7^2
"BLD",790,4,8992.7,0)
8992.7
"BLD",790,4,8992.7,222)
y^y^f^^^^n
"BLD",790,4,8992.8,0)
8992.8
"BLD",790,4,8992.8,222)
y^y^f^^n^^y^m^n
"BLD",790,4,"B",8992.7,8992.7)

"BLD",790,4,"B",8992.8,8992.8)

"BLD",790,6.3)
18
"BLD",790,"KRN",0)
^9.67PA^8989.52^19
"BLD",790,"KRN",.4,0)
.4
"BLD",790,"KRN",.401,0)
.401
"BLD",790,"KRN",.402,0)
.402
"BLD",790,"KRN",.403,0)
.403
"BLD",790,"KRN",.5,0)
.5
"BLD",790,"KRN",.84,0)
.84
"BLD",790,"KRN",3.6,0)
3.6
"BLD",790,"KRN",3.8,0)
3.8
"BLD",790,"KRN",9.2,0)
9.2
"BLD",790,"KRN",9.8,0)
9.8
"BLD",790,"KRN",9.8,"NM",0)
^9.68A^7^7
"BLD",790,"KRN",9.8,"NM",1,0)
XTMRPRNT^^0^B1220842
"BLD",790,"KRN",9.8,"NM",2,0)
XTMLOG^^0^B133645760
"BLD",790,"KRN",9.8,"NM",3,0)
XTMUNIT^^0^B208648286
"BLD",790,"KRN",9.8,"NM",4,0)
XTMLOG1^^0^B46831784
"BLD",790,"KRN",9.8,"NM",5,0)
XTMLOG2^^1^
"BLD",790,"KRN",9.8,"NM",6,0)
XTMLOPAR^^0^B19404303
"BLD",790,"KRN",9.8,"NM",7,0)
XTMLOSKT^^0^B36861478
"BLD",790,"KRN",9.8,"NM","B","XTMLOG",2)

"BLD",790,"KRN",9.8,"NM","B","XTMLOG1",4)

"BLD",790,"KRN",9.8,"NM","B","XTMLOG2",5)

"BLD",790,"KRN",9.8,"NM","B","XTMLOPAR",6)

"BLD",790,"KRN",9.8,"NM","B","XTMLOSKT",7)

"BLD",790,"KRN",9.8,"NM","B","XTMRPRNT",1)

"BLD",790,"KRN",9.8,"NM","B","XTMUNIT",3)

"BLD",790,"KRN",19,0)
19
"BLD",790,"KRN",19,"NM",0)
^9.68A^3^3
"BLD",790,"KRN",19,"NM",1,0)
XTMUNIT^^0
"BLD",790,"KRN",19,"NM",2,0)
XTMUNIT GROUP EDIT^^0
"BLD",790,"KRN",19,"NM",3,0)
XTMUNIT GROUP RUN^^0
"BLD",790,"KRN",19,"NM","B","XTMUNIT",1)

"BLD",790,"KRN",19,"NM","B","XTMUNIT GROUP EDIT",2)

"BLD",790,"KRN",19,"NM","B","XTMUNIT GROUP RUN",3)

"BLD",790,"KRN",19.1,0)
19.1
"BLD",790,"KRN",101,0)
101
"BLD",790,"KRN",409.61,0)
409.61
"BLD",790,"KRN",771,0)
771
"BLD",790,"KRN",870,0)
870
"BLD",790,"KRN",8989.51,0)
8989.51
"BLD",790,"KRN",8989.52,0)
8989.52
"BLD",790,"KRN",8994,0)
8994
"BLD",790,"KRN",8994,"NM",0)
^9.68A^3^3
"BLD",790,"KRN",8994,"NM",1,0)
XTMUNIT-TEST LOAD^^0
"BLD",790,"KRN",8994,"NM",2,0)
XTMUNIT-TEST NEXT^^0
"BLD",790,"KRN",8994,"NM",3,0)
XTMUNIT-TEST GROUP LOAD^^0
"BLD",790,"KRN",8994,"NM","B","XTMUNIT-TEST GROUP LOAD",3)

"BLD",790,"KRN",8994,"NM","B","XTMUNIT-TEST LOAD",1)

"BLD",790,"KRN",8994,"NM","B","XTMUNIT-TEST NEXT",2)

"BLD",790,"KRN","B",.4,.4)

"BLD",790,"KRN","B",.401,.401)

"BLD",790,"KRN","B",.402,.402)

"BLD",790,"KRN","B",.403,.403)

"BLD",790,"KRN","B",.5,.5)

"BLD",790,"KRN","B",.84,.84)

"BLD",790,"KRN","B",3.6,3.6)

"BLD",790,"KRN","B",3.8,3.8)

"BLD",790,"KRN","B",9.2,9.2)

"BLD",790,"KRN","B",9.8,9.8)

"BLD",790,"KRN","B",19,19)

"BLD",790,"KRN","B",19.1,19.1)

"BLD",790,"KRN","B",101,101)

"BLD",790,"KRN","B",409.61,409.61)

"BLD",790,"KRN","B",771,771)

"BLD",790,"KRN","B",870,870)

"BLD",790,"KRN","B",8989.51,8989.51)

"BLD",790,"KRN","B",8989.52,8989.52)

"BLD",790,"KRN","B",8994,8994)

"BLD",790,"QDEF")
^^^^NO^^^^NO^^NO
"BLD",790,"QUES",0)
^9.62^^
"BLD",790,"REQB",0)
^9.611^^
"DATA",8992.8,1,0)
XLFCRC
"DATA",8992.8,1,1,0)
^8992.81^1^1
"DATA",8992.8,1,1,1,0)
ZZMTXLF9
"DATA",8992.8,2,0)
XLFDT
"DATA",8992.8,2,1,0)
^8992.81^4^2
"DATA",8992.8,2,1,1,0)
ZZMTXLF
"DATA",8992.8,2,1,4,0)
ZZMTXLF1
"DATA",8992.8,3,0)
ALERTS
"DATA",8992.8,3,1,0)
^8992.81^5^5
"DATA",8992.8,3,1,1,0)
ZZUTXQA2
"DATA",8992.8,3,1,2,0)
ZZUTXQA1
"DATA",8992.8,3,1,3,0)
ZZUTXQA3
"DATA",8992.8,3,1,4,0)
ZZUTXQA4
"DATA",8992.8,3,1,5,0)
ZZUTXQA5
"DATA",8992.8,3,2,0)
^^1^1^3111228^
"DATA",8992.8,3,2,1,0)
Entry point to run all unit test routines: D ^ZZUTXQA1
"DATA",8992.8,4,0)
XTMRPAR SET
"DATA",8992.8,4,1,0)
^8992.81^2^2
"DATA",8992.8,4,1,1,0)
ZZUTXTM1
"DATA",8992.8,4,1,2,0)
ZZUTXTM2
"DATA",8992.8,5,0)
XLF LIBRARY
"DATA",8992.8,5,1,0)
^8992.81^1^1
"DATA",8992.8,5,1,1,0)
ZZMTXLF
"DATA",8992.8,6,0)
XPAR
"DATA",8992.8,6,1,0)
^8992.81^1^1
"DATA",8992.8,6,1,1,0)
ZZMYXPAR
"DATA",8992.8,6,2,0)
^^3^3^3040701^
"DATA",8992.8,6,2,1,0)
This routine will test the basic calls to XPAR.
"DATA",8992.8,6,2,2,0)
Before a fix is added a new test should be added to show the error and 
"DATA",8992.8,6,2,3,0)
fix.
"DATA",8992.8,7,0)
XML UNIT TEST
"DATA",8992.8,7,1,0)
^8992.81^1^1
"DATA",8992.8,7,1,1,0)
ZZMTXML
"DATA",8992.8,7,2,0)
^^1^1^3050106^
"DATA",8992.8,7,2,1,0)
This runs a set of tests on the MXMLPRSE routines.
"DATA",8992.8,8,0)
XLFSTR
"DATA",8992.8,8,1,0)
^8992.81^1^1
"DATA",8992.8,8,1,1,0)
ZZMTXLF8
"DATA",8992.8,8,2,0)
^^1^1^3060112^
"DATA",8992.8,8,2,1,0)
This will do unit tests on the API's in XLFSTR.
"DATA",8992.8,9,0)
XTDEBUG
"DATA",8992.8,9,1,0)
^8992.81^1^1
"DATA",8992.8,9,1,1,0)
ZZUTXTD1
"DATA",8992.8,9,2,0)
^^1^1^3080117^
"DATA",8992.8,9,2,1,0)
These are tests related to the M-Debugger for Eclipse (XTDEBUG*).
"DATA",8992.8,10,0)
Log4M
"DATA",8992.8,10,1,0)
^8992.81^4^4
"DATA",8992.8,10,1,1,0)
ZZUTXTL1
"DATA",8992.8,10,1,2,0)
ZZUTXTL2
"DATA",8992.8,10,1,3,0)
ZZUTXTL3
"DATA",8992.8,10,1,4,0)
ZZUTXTL4
"DATA",8992.8,10,2,0)
^^1^1^3080220^
"DATA",8992.8,10,2,1,0)
This tests the Log4M tool.
"DATA",8992.8,11,0)
XLFNAME
"DATA",8992.8,11,1,0)
^8992.81^1^1
"DATA",8992.8,11,1,1,0)
ZZUTNAME
"DATA",8992.8,11,2,0)
^^1^1^3081118^
"DATA",8992.8,11,2,1,0)
This is to test changes to the XLFNAME standardization code.
"DATA",8992.8,12,0)
USER NETNAME
"DATA",8992.8,12,1,0)
^8992.81^1^1
"DATA",8992.8,12,1,1,0)
ZZMTUSR1
"DATA",8992.8,12,2,0)
^^1^1^3090930^
"DATA",8992.8,12,2,1,0)
Do unit test on the NETNM^XUSER1.
"FIA",8992.7)
LOG4M CONFIG
"FIA",8992.7,0)
^XTV(8992.7,
"FIA",8992.7,0,0)
8992.7
"FIA",8992.7,0,1)
y^y^f^^^^n
"FIA",8992.7,0,10)

"FIA",8992.7,0,11)

"FIA",8992.7,0,"RLRO")

"FIA",8992.7,0,"VR")
7.3^XT
"FIA",8992.7,8992.7)
0
"FIA",8992.7,8992.71)
0
"FIA",8992.8)
MUNIT TEST GROUP
"FIA",8992.8,0)
^XTV(8992.8,
"FIA",8992.8,0,0)
8992.8
"FIA",8992.8,0,1)
y^y^f^^n^^y^m^n
"FIA",8992.8,0,10)

"FIA",8992.8,0,11)

"FIA",8992.8,0,"RLRO")

"FIA",8992.8,0,"VR")
7.3^XT
"FIA",8992.8,8992.8)
0
"FIA",8992.8,8992.81)
0
"FIA",8992.8,8992.82)
0
"KRN",19,957,-1)
0^1
"KRN",19,957,0)
XTMUNIT^M Unit Tester^^B^^^^^^^^TOOLKIT
"KRN",19,957,"RPC",0)
^19.05P^3^3
"KRN",19,957,"RPC",1,0)
XTMUNIT-TEST LOAD
"KRN",19,957,"RPC",2,0)
XTMUNIT-TEST NEXT
"KRN",19,957,"RPC",3,0)
XTMUNIT-TEST GROUP LOAD
"KRN",19,957,"U")
M UNIT TESTER
"KRN",19,958,-1)
0^2
"KRN",19,958,0)
XTMUNIT GROUP EDIT^MUnit Test Group edit^^E^^^^^^^^TOOLKIT
"KRN",19,958,1,0)
^19.06^6^6^3031030^^^
"KRN",19,958,1,1,0)
This option can be used to maintain a listing of unit tests related to a 
"KRN",19,958,1,2,0)
specific topic.  The Group identifies the topic, and the unit tests 
"KRN",19,958,1,3,0)
related to that topic are added in the multiple.  Unit Tests can be run 
"KRN",19,958,1,4,0)
by selecting a group, and all unit tests included in the multiple will be 
"KRN",19,958,1,5,0)
used for the test.  In addition, any other references under the XTROU tag 
"KRN",19,958,1,6,0)
in any of the included test routines will be included in the run.
"KRN",19,958,30)
XTV(8992.8,
"KRN",19,958,31)
AEMQL
"KRN",19,958,50)
8992.8
"KRN",19,958,51)
.01;1
"KRN",19,958,99.1)
59472,40730
"KRN",19,958,"U")
MUNIT TEST GROUP EDIT
"KRN",19,959,-1)
0^3
"KRN",19,959,0)
XTMUNIT GROUP RUN^Run MUnit Tests from Test Groups^^R^^^^^^^^TOOLKIT
"KRN",19,959,1,0)
^^2^2^3031030^
"KRN",19,959,1,1,0)
Provides a means of initiating a unit test run from the menu system based 
"KRN",19,959,1,2,0)
on entries in the MUNIT TEST GROUP file (#8992.8).
"KRN",19,959,25)
PICKSET^XTMUNIT
"KRN",19,959,99.1)
59472,49965
"KRN",19,959,"U")
RUN MUNIT TESTS FROM TEST GROU
"KRN",8994,112,-1)
0^1
"KRN",8994,112,0)
XTMUNIT-TEST LOAD^GUILOAD^XTMUNIT^4^^^^1
"KRN",8994,113,-1)
0^2
"KRN",8994,113,0)
XTMUNIT-TEST NEXT^GUINEXT^XTMUNIT^4^^^^1
"KRN",8994,114,-1)
0^3
"KRN",8994,114,0)
XTMUNIT-TEST GROUP LOAD^GUISET^XTMUNIT^4^^^^1
"MBREQ")
0
"ORD",0,9.8)
9.8;;1;RTNF^XPDTA;RTNE^XPDTA
"ORD",0,9.8,0)
ROUTINE
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",6,-1)
1^1
"PKG",6,0)
TOOLKIT^XT^PROGRAMMERS OPTIONS, MULTI. TERM LOOKUP^
"PKG",6,20,0)
^9.402P^^0
"PKG",6,22,0)
^9.49I^1^1
"PKG",6,22,1,0)
7.3^3040428^2970513^2
"PKG",6,22,1,"PAH",1,0)
81^3120105^2
"PKG",6,22,1,"PAH",1,1,0)
^^3^3^3120105
"PKG",6,22,1,"PAH",1,1,1,0)
XT*7.3*81
"PKG",6,22,1,"PAH",1,1,2,0)
 
"PKG",6,22,1,"PAH",1,1,3,0)
See the Patch Module for description.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
7
"RTN","XTMLOG")
0^2^B133645760
"RTN","XTMLOG",1,0)
XTMLOG ;JLI/FO-OAK - LOG4M M LOGGING UTILITY ;11/15/10  10:34
"RTN","XTMLOG",2,0)
 ;;7.3;TOOLKIT;**81,101**;Apr 25, 1995;Build 18
"RTN","XTMLOG",3,0)
 ;;Per VHA Directive 2004-038, this routine should not be modified
"RTN","XTMLOG",4,0)
 ;
"RTN","XTMLOG",5,0)
 ; Routine provides logging capability similar in various
"RTN","XTMLOG",6,0)
 ; respects to Log4J.
"RTN","XTMLOG",7,0)
 ;
"RTN","XTMLOG",8,0)
 D EN^XTMUNIT("XTMTSTL1")
"RTN","XTMLOG",9,0)
 Q
"RTN","XTMLOG",10,0)
 ;
"RTN","XTMLOG",11,0)
INITFILE(DIRREF,FILEREF,NAME) ; jli .SR -- Configuration is read a file (DIRREF is the directory, and FILEREF is the filename)
"RTN","XTMLOG",12,0)
 N XTLOGLIN S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",13,0)
 N HOSTGLOB
"RTN","XTMLOG",14,0)
 S HOSTGLOB=$NA(^TMP("XTMLOG1",$J)) K @HOSTGLOB S @HOSTGLOB@(0)=""
"RTN","XTMLOG",15,0)
 I '$$FTG^%ZISH(DIRREF,FILEREF,$NA(@HOSTGLOB@(1)),3) Q 0
"RTN","XTMLOG",16,0)
 Q $$INITIAL(HOSTGLOB,$G(NAME,"XTMLOG"),XTLOGLIN)
"RTN","XTMLOG",17,0)
 ;
"RTN","XTMLOG",18,0)
FILEINIT(NAMEFLD) ; jli .SR -- called as extrinsic function
"RTN","XTMLOG",19,0)
 ; NAMEFLD - input - Name of entry in LOG4M CONFIG file (#8992.7 )
"RTN","XTMLOG",20,0)
 ;                   to be used for setting up logging
"RTN","XTMLOG",21,0)
 ; returns - 0 if initiating logging failed
"RTN","XTMLOG",22,0)
 ;           1 if initiating logging was successful
"RTN","XTMLOG",23,0)
 N XTLOGLIN S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",24,0)
 N XTMLIEN,XTMLACTV,XTMLRES,XTMLERR,XTMLARR,XVAL
"RTN","XTMLOG",25,0)
 ; ZEXCEPT: XTLOGINP - KILLED IN ENDLOG
"RTN","XTMLOG",26,0)
 S XTMLIEN=$O(^XTV(8992.7,"B",NAMEFLD,0)) I XTMLIEN'>0 Q 0
"RTN","XTMLOG",27,0)
 ; get data from the LOG4M CONFIG file
"RTN","XTMLOG",28,0)
 D GETS^DIQ(8992.7,XTMLIEN_",",".02:.08","I","XTMLRES","XTMLERR")
"RTN","XTMLOG",29,0)
 S XTMLARR=$NA(XTMLRES(8992.7,XTMLIEN_","))
"RTN","XTMLOG",30,0)
 ; quit if logging set to NO or it is not there
"RTN","XTMLOG",31,0)
 I ($G(@XTMLARR@(.02,"I"))="N")!($G(@XTMLARR@(.02,"I"))="") Q 0
"RTN","XTMLOG",32,0)
 S XVAL=@XTMLARR@(.07,"I") I (XVAL="M")!(XVAL="P") S XTLOGINP(NAMEFLD,"OUTTYPE")=XVAL,XTLOGINP(NAMEFLD,"OUTSPECS")=@XTMLARR@(.08,"I")
"RTN","XTMLOG",33,0)
 I @XTMLARR@(.02,"I")="E" Q $$INITEASY($G(@XTMLARR@(.03,"I")),$G(@XTMLARR@(.04,"I")),NAMEFLD,XTLOGLIN,$G(@XTMLARR@(.05,"I")),$G(@XTMLARR@(.06,"I")))
"RTN","XTMLOG",34,0)
 Q $$INITIAL($NA(@XTMLARR@(1)),NAMEFLD,XTLOGLIN)
"RTN","XTMLOG",35,0)
 ;
"RTN","XTMLOG",36,0)
INITGLOB(HOSTGLOB,NAME,XTLOGLIN) ; Configuration data is read under a global root - HOSTGLOB is a closed global root
"RTN","XTMLOG",37,0)
 I '$D(XTLOGLIN) S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",38,0)
 Q $$INITIAL(HOSTGLOB,$G(NAME,"XTMLOG"),XTLOGLIN)
"RTN","XTMLOG",39,0)
 ;
"RTN","XTMLOG",40,0)
INITNONE(NAME) ; No configuration data to read - use defaults - console and global logging
"RTN","XTMLOG",41,0)
 N XTLOGLIN S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",42,0)
 Q $$INITIAL("",$G(NAME,"XTMLOG"),"",XTLOGLIN)
"RTN","XTMLOG",43,0)
 ;
"RTN","XTMLOG",44,0)
INITEASY(CONFIG,LEVEL,NAME,XTLOGLIN,XTMLROUS,XTMLUSRS) ;
"RTN","XTMLOG",45,0)
 ; for INITEASY indicate the type of appenders desired as a series of ';'-pieces with names or first
"RTN","XTMLOG",46,0)
 ; letters to identify the appender type [C(onsole), (G)lobal, and S(ocket)].
"RTN","XTMLOG",47,0)
 ;    Global and Socket may have additional specifications separated by a Comma after the name
"RTN","XTMLOG",48,0)
 ;    indicator
"RTN","XTMLOG",49,0)
 ;       Global  -- Top Subscript under XTMP, if not specified "XTMLOG" is the default
"RTN","XTMLOG",50,0)
 ;       Socket  -- Port number for output of the logging data, if not specified 8025 is the default
"RTN","XTMLOG",51,0)
 ;
"RTN","XTMLOG",52,0)
 ;    use of D INITEASY^XTMLOG1("C;G,LOGDATA;S,9450","WARN") would have logging sent to
"RTN","XTMLOG",53,0)
 ;            the console,
"RTN","XTMLOG",54,0)
 ;            stored under ^XTMP("LOGDATA",  for a week, and
"RTN","XTMLOG",55,0)
 ;            sent out on a socket at port 9450 on the current system in real time
"RTN","XTMLOG",56,0)
 ;            for calls with priority or level at WARN or above.
"RTN","XTMLOG",57,0)
 ;
"RTN","XTMLOG",58,0)
 ;  XTMLROUS - An optional string containing a comma-separated list of routine names or namespaces,
"RTN","XTMLOG",59,0)
 ;            namespaces are indicated by an asterick following the namespace characters.
"RTN","XTMLOG",60,0)
 ;
"RTN","XTMLOG",61,0)
 I '$D(XTLOGLIN) N XTLOGLIN S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",62,0)
 S CONFIG="*"_CONFIG I $G(LEVEL)'="" S CONFIG=CONFIG_";,"_LEVEL
"RTN","XTMLOG",63,0)
 Q $$INITIAL(CONFIG,$G(NAME,"XTMLOG"),XTLOGLIN,$G(XTMLROUS),$G(XTMLUSRS))
"RTN","XTMLOG",64,0)
 ;
"RTN","XTMLOG",65,0)
INITIAL(HOSTGLOB,NAME,XTLOGLIN,XTMLROUS,XTMLUSRS) ;
"RTN","XTMLOG",66,0)
 N XX,TESTLIST,I,X,XTCMLCNT,XTMLROU,XTMLCNT,XTMLRCNT
"RTN","XTMLOG",67,0)
 N XTLOGSET
"RTN","XTMLOG",68,0)
 ; ZEXCEPT: XTLOGINP - KILLED IN ENDLOG
"RTN","XTMLOG",69,0)
 I $G(XTMLUSRS)'="",(","_XTMLUSRS_",")'[(","_DUZ_",") Q 0 ; DON'T LOG FOR THIS USER
"RTN","XTMLOG",70,0)
 I $G(XTLOGLIN)="" S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",71,0)
 S NAME=$G(NAME,"XTMLOG"),XTMLROUS=$G(XTMLROUS)
"RTN","XTMLOG",72,0)
 I $G(HOSTGLOB)'="",$E(HOSTGLOB)'="*" D PARSE(NAME,HOSTGLOB,.XTLOGINP) I '$D(XTLOGINP) Q 0
"RTN","XTMLOG",73,0)
 S TESTLIST="FATAL^ERROR^WARN^INFO^DEBUG",XTLOGSET=""
"RTN","XTMLOG",74,0)
 I $E(HOSTGLOB)="*" D EASYSET($E(HOSTGLOB,2,99),NAME,.XTLOGINP)
"RTN","XTMLOG",75,0)
 D DEFAULTS(NAME,.XTLOGINP) ; set defaults if values not present
"RTN","XTMLOG",76,0)
 F I=1:1:5 S X=$P(TESTLIST,U,I) S XTLOGSET=XTLOGSET_","_I I X=XTLOGINP(NAME,"PRIORITY") Q
"RTN","XTMLOG",77,0)
 S XTLOGINP(NAME,"LOGSET")=XTLOGSET_",",XTLOGINP(NAME,"COUNT")=0
"RTN","XTMLOG",78,0)
 S XTMLRCNT=0 F I=1:1 S XTMLROU=$P($G(XTMLROUS),",",I) Q:XTMLROU=""  S XTMLRCNT=XTMLRCNT+1,XTLOGINP(NAME,"ROUS",XTMLRCNT)=XTMLROU,XTLOGINP(NAME,"ROUS")=XTMLRCNT
"RTN","XTMLOG",79,0)
 Q 1
"RTN","XTMLOG",80,0)
 ;
"RTN","XTMLOG",81,0)
CHKRLST(LOCATION,ROUNAME) ; function - indicates whether ROUNAME is among selected routines for logging
"RTN","XTMLOG",82,0)
 I $O(@LOCATION@("ROUS",0))'>0 Q 1
"RTN","XTMLOG",83,0)
 N I,VAL,XTMLRNAM
"RTN","XTMLOG",84,0)
 S VAL=0 F I=0:0 S I=$O(@LOCATION@("ROUS",I)) Q:I'>0  D  Q:VAL
"RTN","XTMLOG",85,0)
 . I @LOCATION@("ROUS",I)["*" S XTMLRNAM=$P(@LOCATION@("ROUS",I),"*") I $E(ROUNAME,1,$L(XTMLRNAM))=XTMLRNAM S VAL=1
"RTN","XTMLOG",86,0)
 . I @LOCATION@("ROUS",I)'["*",@LOCATION@("ROUS",I)=ROUNAME S VAL=1
"RTN","XTMLOG",87,0)
 . Q
"RTN","XTMLOG",88,0)
 Q VAL
"RTN","XTMLOG",89,0)
 ;
"RTN","XTMLOG",90,0)
STOPLOG(XTLOGNAM,OUTTYPE,OUTSPECS) ; JUST ANOTHER NAME FOR ENDLOG
"RTN","XTMLOG",91,0)
 D ENDLOG($G(XTLOGNAM),$G(OUTTYPE),$G(OUTSPECS))
"RTN","XTMLOG",92,0)
 Q
"RTN","XTMLOG",93,0)
 ;
"RTN","XTMLOG",94,0)
ENDLOG(XTLOGNAM,OUTTYPE,OUTSPECS) ; OUTTYPE, AND OUTSPECS ARE OPTIONAL - REMOVES LOGNAM FROM LOGGING
"RTN","XTMLOG",95,0)
 ; ZEXCEPT: XTLOGINP - KILLED HERE, SET ELSEWHERE
"RTN","XTMLOG",96,0)
 S XTLOGNAM=$G(XTLOGNAM,"XTMLOG")
"RTN","XTMLOG",97,0)
 I $G(OUTTYPE)="M"!($G(XTLOGINP(XTLOGNAM,"OUTTYPE"))="M") D SENDMAIL(XTLOGNAM,$S($G(OUTSPECS)'="":OUTSPECS,$G(XTLOGINP(XTLOGNAM,"OUTSPECS"))'="":XTLOGINP(XTLOGNAM,"OUTSPECS"),1:""))
"RTN","XTMLOG",98,0)
 I $G(OUTTYPE)="P"!($G(XTLOGINP(XTLOGNAM,"OUTTYPE"))="P") D PRINTIT(XTLOGNAM,$S($G(OUTSPECS)'="":OUTSPECS,$G(XTLOGINP(XTLOGNAM,"OUTSPECS"))'="":XTLOGINP(XTLOGNAM,"OUTSPECS"),1:""))
"RTN","XTMLOG",99,0)
 K XTLOGINP(XTLOGNAM)
"RTN","XTMLOG",100,0)
 Q
"RTN","XTMLOG",101,0)
 ;
"RTN","XTMLOG",102,0)
EASYSET(CONFIG,NAME,XTLOGINP) ;
"RTN","XTMLOG",103,0)
 N X
"RTN","XTMLOG",104,0)
 F  Q:CONFIG=""  S X=$P(CONFIG,";"),CONFIG=$P(CONFIG,";",2,99) D
"RTN","XTMLOG",105,0)
 . I $E(X)="C" D SETCONSO("C",NAME,.XTLOGINP)
"RTN","XTMLOG",106,0)
 . I $E(X)="G" D SETGLOB("G",$P(X,",",2),NAME,.XTLOGINP)
"RTN","XTMLOG",107,0)
 . I $E(X)="S" D SETSOCK("S",$P(X,",",2),NAME,.XTLOGINP)
"RTN","XTMLOG",108,0)
 . I $E(X)="," D SETLEVEL($P(X,",",2),NAME,.XTLOGINP)
"RTN","XTMLOG",109,0)
 . Q
"RTN","XTMLOG",110,0)
 Q
"RTN","XTMLOG",111,0)
 ;
"RTN","XTMLOG",112,0)
DEFAULTS(NAME,XTLOGINP) ; XTLOGINP is passed by reference
"RTN","XTMLOG",113,0)
 I '$D(XTLOGINP(NAME,"PRIORITY")) S XTLOGINP(NAME,"PRIORITY")="DEBUG" ; default priority is DEBUG
"RTN","XTMLOG",114,0)
 I '$D(XTLOGINP(NAME,"APPENDER")) D SETCONSO("A",NAME,.XTLOGINP) ; default is CONSOLEAPPENDER
"RTN","XTMLOG",115,0)
 Q
"RTN","XTMLOG",116,0)
 ;
"RTN","XTMLOG",117,0)
SETCONSO(ID,NAME,XTLOGINP) ;
"RTN","XTMLOG",118,0)
 N NODE
"RTN","XTMLOG",119,0)
 S NODE=$NA(XTLOGINP(NAME,"APPENDER",ID))
"RTN","XTMLOG",120,0)
 S @NODE@("TYPE")="CONSOLEAPPENDER",@NODE@("LAYOUT")="PATTERNLAYOUT"
"RTN","XTMLOG",121,0)
 S @NODE@("LAYOUT.CONVERSIONPATTERN")="%d %-5p %L %F - %m%n"
"RTN","XTMLOG",122,0)
 Q
"RTN","XTMLOG",123,0)
 ;
"RTN","XTMLOG",124,0)
SETGLOB(ID,SUBSCRIP,NAME,XTLOGINP) ;
"RTN","XTMLOG",125,0)
 N NODE,INFO
"RTN","XTMLOG",126,0)
 S NODE=$NA(XTLOGINP(NAME,"APPENDER",ID))
"RTN","XTMLOG",127,0)
 S @NODE@("TYPE")="GLOBAL",@NODE@("LAYOUT")="PATTERNLAYOUT"
"RTN","XTMLOG",128,0)
 S @NODE@("LAYOUT.CONVERSIONPATTERN")="%d %-5p %L %F - %m%n"
"RTN","XTMLOG",129,0)
 S SUBSCRIP=$S($G(SUBSCRIP)="":"XTMLOG",1:SUBSCRIP)
"RTN","XTMLOG",130,0)
 S:'$D(INFO("$H")) INFO("$H")=$H
"RTN","XTMLOG",131,0)
 N XTMLOGDT,FORMAT S FORMAT="{yyMMdd.HHmmss",XTMLOGDT=$$GETDATE^XTMLOG1(.INFO,.FORMAT)
"RTN","XTMLOG",132,0)
 S @NODE@("CLOSEDROOT")=$NA(^XTMP(SUBSCRIP,DUZ,XTMLOGDT,$J)) ; use current $H as constant and $J
"RTN","XTMLOG",133,0)
 S ^XTMP(SUBSCRIP,0)=$$FMADD^XLFDT(DT,7) ; Mark it to be saved for a week
"RTN","XTMLOG",134,0)
 Q
"RTN","XTMLOG",135,0)
 ;
"RTN","XTMLOG",136,0)
SETSOCK(ID,PORT,NAME,XTLOGINP) ;
"RTN","XTMLOG",137,0)
 N NODE
"RTN","XTMLOG",138,0)
 S NODE=$NA(XTLOGINP(NAME,"APPENDER",ID))
"RTN","XTMLOG",139,0)
 S @NODE@("TYPE")="SOCKETAPPENDER",@NODE@("LAYOUT")="PATTERNLAYOUT"
"RTN","XTMLOG",140,0)
 S @NODE@("LAYOUT.CONVERSIONPATTERN")="%d %-5p %L %F - %m%n"
"RTN","XTMLOG",141,0)
 S PORT=$S($G(PORT)="":8025,1:PORT)
"RTN","XTMLOG",142,0)
 S @NODE@("PORT")=PORT
"RTN","XTMLOG",143,0)
 D START^XTMLOSKT(PORT) ; Start socket running if it isn't already
"RTN","XTMLOG",144,0)
 Q
"RTN","XTMLOG",145,0)
 ;
"RTN","XTMLOG",146,0)
SETLEVEL(LEVEL,NAME,XTLOGINP) ;
"RTN","XTMLOG",147,0)
 N X
"RTN","XTMLOG",148,0)
 S X=$$UP^XLFSTR($E(LEVEL)),X=$S(X="D":5,X="I":4,X="W":3,X="E":2,X="F":1,1:5)
"RTN","XTMLOG",149,0)
 S XTLOGINP(NAME,"PRIORITY")=$P("FATAL^ERROR^WARN^INFO^DEBUG",U,X)
"RTN","XTMLOG",150,0)
 Q
"RTN","XTMLOG",151,0)
 ;
"RTN","XTMLOG",152,0)
PARSE(NAME,GLOBREF,RESULTS) ; parse configuration file - RESULTS is passed by reference
"RTN","XTMLOG",153,0)
 N XTMROOT,FILTYPE,INDEX,XLINE
"RTN","XTMLOG",154,0)
 N APPENDER,APPENDID,APPENDTY,I,REST
"RTN","XTMLOG",155,0)
 S FILTYPE="PROPERTIES"
"RTN","XTMLOG",156,0)
 S INDEX="" F  S INDEX=$O(@GLOBREF@(INDEX)) Q:INDEX=""  S XLINE=$G(@GLOBREF@(INDEX)) S:XLINE="" XLINE=$G(@GLOBREF@(INDEX,0)) I XLINE'="" S:XLINE["<?xml" FILTYPE="XML" Q
"RTN","XTMLOG",157,0)
 ;
"RTN","XTMLOG",158,0)
 I FILTYPE="XML" D ENTRY^XTMLOPAR(NAME,GLOBREF,.RESULTS) Q  ; Handle xml separately
"RTN","XTMLOG",159,0)
 ;
"RTN","XTMLOG",160,0)
 S INDEX="" F  S INDEX=$O(@GLOBREF@(INDEX)) Q:INDEX=""  S XLINE=$G(@GLOBREF@(INDEX)) S:XLINE="" XLINE=$G(@GLOBREF@(INDEX,0)) D
"RTN","XTMLOG",161,0)
 . S XLINE=$P(XLINE,"#") Q:XLINE=""
"RTN","XTMLOG",162,0)
 . ; have to get the rootlogger info first
"RTN","XTMLOG",163,0)
 . I '$D(XTMROOT) Q:$$UP^XLFSTR(XLINE)'["ROOTLOGGER"  D  Q
"RTN","XTMLOG",164,0)
 . . S XLINE=$P(XLINE,"=",2),XLINE=$TR(XLINE," ","")
"RTN","XTMLOG",165,0)
 . . S RESULTS(NAME,"PRIORITY")=$$UP^XLFSTR($P(XLINE,",")),XTMROOT=""
"RTN","XTMLOG",166,0)
 . . F  S XLINE=$P(XLINE,",",2,99) Q:XLINE=""  S RESULTS(NAME,"APPENDER",$$UP^XLFSTR($P(XLINE,",")))=""
"RTN","XTMLOG",167,0)
 . . Q
"RTN","XTMLOG",168,0)
 . S APPENDER=$P($$UP^XLFSTR(XLINE),"APPENDER.",2),REST=$P(XLINE,"=",2,99),APPENDER=$P(APPENDER,"=")
"RTN","XTMLOG",169,0)
 . S APPENDID=$P(APPENDER,"."),APPENDTY=$P(APPENDER,".",2,99)
"RTN","XTMLOG",170,0)
 . I APPENDTY="" S APPENDTY=$P(REST,".",$L(REST,".")) D
"RTN","XTMLOG",171,0)
 . . N STR,STR1,STR2 S STR="CONSOLEAPPENDER^ROLLINGFILEAPPENDER",STR2="CONSOLE^ROLLFILE"
"RTN","XTMLOG",172,0)
 . . F I=1:1 S STR1=$P(STR,U,I) Q:STR1=""  I $$UP^XLFSTR(APPENDTY)=STR1 S RESULTS(NAME,"APPENDER",APPENDID,"TYPE")=$E(STR1,1,8) Q
"RTN","XTMLOG",173,0)
 . . I STR1="" S RESULTS(NAME,"APPENDER",APPENDID,"TYPE")="UNKNOWN"
"RTN","XTMLOG",174,0)
 . . Q
"RTN","XTMLOG",175,0)
 . I APPENDTY="LAYOUT" S RESULTS(NAME,"APPENDER",APPENDID,APPENDTY)=$$UP^XLFSTR($P(REST,".",$L(REST,".")))
"RTN","XTMLOG",176,0)
 . E  S RESULTS(NAME,"APPENDER",APPENDID,APPENDTY)=REST
"RTN","XTMLOG",177,0)
 . Q
"RTN","XTMLOG",178,0)
 Q
"RTN","XTMLOG",179,0)
 ;
"RTN","XTMLOG",180,0)
ENABLED(NAME) ; .SR returns 1 if NAME is active -- USAGE $$ENABLED^XTMLOG1(NAME)
"RTN","XTMLOG",181,0)
 ; ZEXCEPT: XTLOGINP - CREATED IN INITIAL, KILLED IN ENDLOG
"RTN","XTMLOG",182,0)
 Q $S($D(XTLOGINP(NAME)):1,1:0)
"RTN","XTMLOG",183,0)
 ;
"RTN","XTMLOG",184,0)
DEBNABLD(NAME) ; .SR  returns 1 if DEBUG is enabled, otherwise zero
"RTN","XTMLOG",185,0)
 ; ZEXCEPT: XTLOGINP - CREATED IN INITIAL, KILLED IN ENDLOG
"RTN","XTMLOG",186,0)
 Q XTLOGINP(NAME,"LOGSET")[",5,"
"RTN","XTMLOG",187,0)
 ;
"RTN","XTMLOG",188,0)
INFNABLD(NAME) ;
"RTN","XTMLOG",189,0)
 ; ZEXCEPT: XTLOGINP - CREATED IN INITIAL, KILLED IN ENDLOG
"RTN","XTMLOG",190,0)
 Q XTLOGINP(NAME,"LOGSET")[",4,"
"RTN","XTMLOG",191,0)
 ;
"RTN","XTMLOG",192,0)
WARNABLD(NAME) ;
"RTN","XTMLOG",193,0)
 ; ZEXCEPT: XTLOGINP - CREATED IN INITIAL, KILLED IN ENDLOG
"RTN","XTMLOG",194,0)
 Q XTLOGINP(NAME,"LOGSET")[",3,"
"RTN","XTMLOG",195,0)
 ;
"RTN","XTMLOG",196,0)
ERRNABLD(NAME) ;
"RTN","XTMLOG",197,0)
 ; ZEXCEPT: XTLOGINP - CREATED IN INITIAL, KILLED IN ENDLOG
"RTN","XTMLOG",198,0)
 Q XTLOGINP(NAME,"LOGSET")[",2,"
"RTN","XTMLOG",199,0)
 ;
"RTN","XTMLOG",200,0)
FATNABLD(NAME) ;
"RTN","XTMLOG",201,0)
 ; ZEXCEPT: XTLOGINP - CREATED IN INITIAL, KILLED IN ENDLOG
"RTN","XTMLOG",202,0)
 Q XTLOGINP(NAME,"LOGSET")[",1,"
"RTN","XTMLOG",203,0)
 ;
"RTN","XTMLOG",204,0)
DEBUG(MESG,VARS,XTMLOARR) ; .SR
"RTN","XTMLOG",205,0)
 ; ZEXCEPT: XTLOGINP - CREATED IN INITIAL, KILLED IN ENDLOG
"RTN","XTMLOG",206,0)
 I '$D(XTLOGINP) Q
"RTN","XTMLOG",207,0)
 N XTLOGINF
"RTN","XTMLOG",208,0)
 N XTLOGLIN S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",209,0)
 S XTLOGINF("PRIORITY")="DEBUG"
"RTN","XTMLOG",210,0)
 D LOG(MESG,5,XTLOGLIN,$G(VARS),$G(XTMLOARR))
"RTN","XTMLOG",211,0)
 Q
"RTN","XTMLOG",212,0)
 ;
"RTN","XTMLOG",213,0)
INFO(MESG,VARS,XTMLOARR) ; .SR
"RTN","XTMLOG",214,0)
 ; ZEXCEPT: XTLOGINP - CREATED IN INITIAL, KILLED IN ENDLOG
"RTN","XTMLOG",215,0)
 I '$D(XTLOGINP) Q
"RTN","XTMLOG",216,0)
 N XTLOGINF
"RTN","XTMLOG",217,0)
 N XTLOGLIN S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",218,0)
 S XTLOGINF("PRIORITY")="INFO"
"RTN","XTMLOG",219,0)
 D LOG(MESG,4,XTLOGLIN,$G(VARS),$G(XTMLOARR))
"RTN","XTMLOG",220,0)
 Q
"RTN","XTMLOG",221,0)
 ;
"RTN","XTMLOG",222,0)
WARN(MESG,VARS,XTMLOARR) ; .SR
"RTN","XTMLOG",223,0)
 ; ZEXCEPT: XTLOGINP - CREATED IN INITIAL, KILLED IN ENDLOG
"RTN","XTMLOG",224,0)
 I '$D(XTLOGINP) Q
"RTN","XTMLOG",225,0)
 N XTLOGINF
"RTN","XTMLOG",226,0)
 N XTLOGLIN S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",227,0)
 S XTLOGINF("PRIORITY")="WARN"
"RTN","XTMLOG",228,0)
 D LOG(MESG,3,XTLOGLIN,$G(VARS),$G(XTMLOARR))
"RTN","XTMLOG",229,0)
 Q
"RTN","XTMLOG",230,0)
 ;
"RTN","XTMLOG",231,0)
ERROR(MESG,VARS,XTMLOARR) ; .SR
"RTN","XTMLOG",232,0)
 ; ZEXCEPT: XTLOGINP - CREATED IN INITIAL, KILLED IN ENDLOG
"RTN","XTMLOG",233,0)
 I '$D(XTLOGINP) Q
"RTN","XTMLOG",234,0)
 N XTLOGINF
"RTN","XTMLOG",235,0)
 N XTLOGLIN S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",236,0)
 S XTLOGINF("PRIORITY")="ERROR"
"RTN","XTMLOG",237,0)
 D LOG(MESG,2,XTLOGLIN,$G(VARS),$G(XTMLOARR))
"RTN","XTMLOG",238,0)
 Q
"RTN","XTMLOG",239,0)
 ;
"RTN","XTMLOG",240,0)
FATAL(MESG,VARS,XTMLOARR) ; .SR
"RTN","XTMLOG",241,0)
 ; ZEXCEPT: XTLOGINP - CREATED IN INITIAL, KILLED IN ENDLOG
"RTN","XTMLOG",242,0)
 I '$D(XTLOGINP) Q
"RTN","XTMLOG",243,0)
 N XTLOGINF
"RTN","XTMLOG",244,0)
 N XTLOGLIN S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",245,0)
 S XTLOGINF("PRIORITY")="FATAL"
"RTN","XTMLOG",246,0)
 D LOG(MESG,1,XTLOGLIN,$G(VARS),$G(XTMLOARR))
"RTN","XTMLOG",247,0)
 Q
"RTN","XTMLOG",248,0)
 ;
"RTN","XTMLOG",249,0)
LOG(MESG,SET,XTLOGLIN,VARS,XTMLOARR) ; .SR  entry point for logging an item
"RTN","XTMLOG",250,0)
 ; this will be ignored unless SETUP^XTMLOG has been called previously
"RTN","XTMLOG",251,0)
 ; MESG - any text that should be recorded for the current location
"RTN","XTMLOG",252,0)
 ;        (Required)
"RTN","XTMLOG",253,0)
 ;
"RTN","XTMLOG",254,0)
 ; SET - a set number if desired (if none is specified, it will always
"RTN","XTMLOG",255,0)
 ;       be logged when logging is active) set numbers may be integer
"RTN","XTMLOG",256,0)
 ;       values used to indicate a group of logging calls which are
"RTN","XTMLOG",257,0)
 ;       similar and should be active at the same time.  Using SETS a
"RTN","XTMLOG",258,0)
 ;       number of log points may be set up, but only those in an
"RTN","XTMLOG",259,0)
 ;       active set, or with no set specified will be recorded.  Thus,
"RTN","XTMLOG",260,0)
 ;       input data might be logged in set 1, values associated with a
"RTN","XTMLOG",261,0)
 ;       process might be set 2, etc. Specific sets that are active are
"RTN","XTMLOG",262,0)
 ;       specified through the SET parameter in the SETUP call.
"RTN","XTMLOG",263,0)
 ;
"RTN","XTMLOG",264,0)
 I '$D(XTLOGINP) Q
"RTN","XTMLOG",265,0)
 N APPENDID,APPNAME,APPTYPE,NAME,XTMECNT,XTMGLOB
"RTN","XTMLOG",266,0)
 ; ZEXCEPT: XTLOGINF,XTLOGINP
"RTN","XTMLOG",267,0)
 I $G(XTLOGLIN)="" S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",268,0)
 N XTMACTIV
"RTN","XTMLOG",269,0)
 S NAME="" F  S NAME=$O(XTLOGINP(NAME)) Q:NAME=""  D
"RTN","XTMLOG",270,0)
 . I $G(XTLOGINP(NAME,"LOGSET"))'="",$G(SET)'="",XTLOGINP(NAME,"LOGSET")'[(","_SET_",") Q  ; only process if set is in those specified or is not specified
"RTN","XTMLOG",271,0)
 . I '$$CHKRLST($NA(XTLOGINP(NAME)),$P(XTLOGLIN,"^",2)) Q
"RTN","XTMLOG",272,0)
 . S XTMACTIV(NAME)=""
"RTN","XTMLOG",273,0)
 . Q
"RTN","XTMLOG",274,0)
 I '$D(XTMACTIV) Q
"RTN","XTMLOG",275,0)
 ;
"RTN","XTMLOG",276,0)
 I $D(XTLOGINP) S NAME="" F  S NAME=$O(XTMACTIV(NAME)) Q:NAME=""  D
"RTN","XTMLOG",277,0)
 . S XTLOGINP(NAME,"COUNT")=$G(XTLOGINP(NAME,"COUNT"))+1
"RTN","XTMLOG",278,0)
 . S XTLOGINF("PRIORITY")=$S($D(SET):$P("FATAL^ERROR^WARN^INFO^DEBUG",U,SET),1:"    ")
"RTN","XTMLOG",279,0)
 . S XTLOGINF("$H")=$H,XTLOGINF("LOCATION")=XTLOGLIN
"RTN","XTMLOG",280,0)
 . S XTLOGINF("COUNT")=XTLOGINP(NAME,"COUNT")
"RTN","XTMLOG",281,0)
 . S APPENDID=""
"RTN","XTMLOG",282,0)
 . F  S APPENDID=$O(XTLOGINP(NAME,"APPENDER",APPENDID)) Q:APPENDID=""  D
"RTN","XTMLOG",283,0)
 . . S APPNAME="APPENDER",APPTYPE=XTLOGINP(NAME,APPNAME,APPENDID,"TYPE")
"RTN","XTMLOG",284,0)
 . . I $T(@($E(APPTYPE,1,8)_"^XTMLOG1"))'="" D @($E(APPTYPE,1,8)_"^XTMLOG1($NA(XTLOGINP(NAME,APPNAME,APPENDID)),.XTLOGINF,$G(MESG),$G(VARS),$G(XTMLOARR))") I 1
"RTN","XTMLOG",285,0)
 . . E  I '$G(XTMECNT) S $ZE="APPENDER *"_APPTYPE_"* NOT SUPPORTED IN XTMLOG1" D ^%ZTER S XTMECNT=1 ; indicate that appender is not available
"RTN","XTMLOG",286,0)
 . . Q
"RTN","XTMLOG",287,0)
 . Q
"RTN","XTMLOG",288,0)
 Q
"RTN","XTMLOG",289,0)
 ;
"RTN","XTMLOG",290,0)
SENDMAIL(XTMLOGID,RECIP) ; internal - used to generate an e-mail report.
"RTN","XTMLOG",291,0)
 N XMY,XMSUB,XMTEXT,XTMMAIL,XTI
"RTN","XTMLOG",292,0)
 I $G(RECIP)="" S XMY(DUZ)=""
"RTN","XTMLOG",293,0)
 E  F XTI=1:1 Q:$P(RECIP,";",XTI)=""  S XMY($P(RECIP,";",XTI))=""
"RTN","XTMLOG",294,0)
 S XTMMAIL=$NA(^TMP($J,"XTMLOG")) K @XTMMAIL
"RTN","XTMLOG",295,0)
 S XMSUB="Logged Data: "_XTMLOGID,XMTEXT="^TMP($J,""XTMLOG"","
"RTN","XTMLOG",296,0)
 I '$$SETGLOB1(XTMLOGID,XTMMAIL) Q  ; NO GLOBAL DATA TO SEND
"RTN","XTMLOG",297,0)
 D ^XMD
"RTN","XTMLOG",298,0)
 Q
"RTN","XTMLOG",299,0)
 ;
"RTN","XTMLOG",300,0)
PRINTIT(XTMLOGID,LOC) ; internal - LOC is printer specification in format for IOP
"RTN","XTMLOG",301,0)
 N GLOBLOC,IOP,I
"RTN","XTMLOG",302,0)
 S GLOBLOC=$NA(^TMP($J,"XTMLOG")) K @GLOBLOC
"RTN","XTMLOG",303,0)
 I '$$SETGLOB1(XTMLOGID,GLOBLOC) Q  ; NO GLOBAL DATA TO SEND
"RTN","XTMLOG",304,0)
 I $G(LOC)'="" S IOP=LOC D ^%ZIS U IO
"RTN","XTMLOG",305,0)
 F I=0:0 S I=$O(@GLOBLOC@(I)) Q:I'>0  W !,^(I)
"RTN","XTMLOG",306,0)
 I $G(LOC)'="" D ^%ZISC
"RTN","XTMLOG",307,0)
 Q
"RTN","XTMLOG",308,0)
 ;
"RTN","XTMLOG",309,0)
SETGLOB1(XTMLOGID,GLOBLOC) ; internal - move current data into output format
"RTN","XTMLOG",310,0)
 ; GLOBLOC is a closed global reference under which the output will be stored without zero nodes
"RTN","XTMLOG",311,0)
 N ROOT,NCNT,X1,X2,X3,X4
"RTN","XTMLOG",312,0)
 ; ZEXCEPT: XTLOGINP - CREATED ON INITIALIZATION, KILLED IN ENDLOG
"RTN","XTMLOG",313,0)
 S ROOT=$G(XTLOGINP(XTMLOGID,"APPENDER","G","CLOSEDROOT"))
"RTN","XTMLOG",314,0)
 I ROOT="" Q 0 ; NO GLOBAL REFERENCE - SO NO DATA
"RTN","XTMLOG",315,0)
 S NCNT=0
"RTN","XTMLOG",316,0)
 ; X1=CURRENT DATE/TIME X2=LOG SEQUENCE NUMBER X3=LINE^ROUTINE X4=COUNT IN CURRENT LOGGING
"RTN","XTMLOG",317,0)
 S X1="" F  S X1=$O(@ROOT@(X1)) Q:X1=""  S X2="" F  S X2=$O(@ROOT@(X1,X2)) Q:X2=""  S X3="" F  S X3=$O(@ROOT@(X1,X2,X3)) Q:X3=""  S X4="" F  S X4=$O(@ROOT@(X1,X2,X3,X4)) Q:X4=""  S NCNT=NCNT+1,@GLOBLOC@(NCNT)=@ROOT@(X1,X2,X3,X4)
"RTN","XTMLOG",318,0)
 Q NCNT>0
"RTN","XTMLOG",319,0)
 ;
"RTN","XTMLOG",320,0)
REALERR ; entry to log a real error
"RTN","XTMLOG",321,0)
 N XTLOGLIN,NAME,XTLOGINF,MESG
"RTN","XTMLOG",322,0)
 ; ZEXCEPT: XTLOGINP - CREATED ON INITIALIZATION, KILLED IN ENDLOG
"RTN","XTMLOG",323,0)
 S XTLOGLIN=$P($STACK($STACK-1,"PLACE")," ")
"RTN","XTMLOG",324,0)
 S MESG="Encountered Error: "_$ZE
"RTN","XTMLOG",325,0)
 S XTLOGINF("PRIORITY")="FATAL"
"RTN","XTMLOG",326,0)
 D LOG(MESG,1) S NAME="" F  S NAME=$O(XTLOGINP(NAME)) Q:NAME=""  D ENDLOG(NAME)
"RTN","XTMLOG",327,0)
 S $ETRAP=""
"RTN","XTMLOG",328,0)
 G ERR^ZU
"RTN","XTMLOG",329,0)
 Q
"RTN","XTMLOG1")
0^4^B46831784
"RTN","XTMLOG1",1,0)
XTMLOG1 ;jli/fo-oak - handle appender functions for Log4M ;06/07/08  17:06
"RTN","XTMLOG1",2,0)
 ;;7.3;TOOLKIT;**81**;Apr 25, 1995;Build 18
"RTN","XTMLOG1",3,0)
 ;;Per VHA Directive 2004-038, this routine should not be modified
"RTN","XTMLOG1",4,0)
 Q
"RTN","XTMLOG1",5,0)
 ; Each appender name is truncated to a max of eight characters and is a tag for the processing
"RTN","XTMLOG1",6,0)
 ; for that appender.
"RTN","XTMLOG1",7,0)
 ; 1st Argument is closed root for the appender information in the XTMINPUT array.
"RTN","XTMLOG1",8,0)
 ;      i.e.,  XTMINPUT(NAME,"APPENDER",APPENDID) The full appender name is at @ROOT@("TYPE")
"RTN","XTMLOG1",9,0)
 ;
"RTN","XTMLOG1",10,0)
 ; 2nd Argument is INFO data
"RTN","XTMLOG1",11,0)
 ;
"RTN","XTMLOG1",12,0)
 ; 3rd Argument is Message sent by logging call
"RTN","XTMLOG1",13,0)
 ;
"RTN","XTMLOG1",14,0)
 ; 4th Argument (optional) is a string of comma separated variable names, which will be included in the output.
"RTN","XTMLOG1",15,0)
 ;      Global nodes should be entered using $NA(
"RTN","XTMLOG1",16,0)
 ;      Example:  "VALUE1,VALUE2"  or  "VALUE1,"_$NA(^TMP($J,"VALUE"))_",VALUE2"
"RTN","XTMLOG1",17,0)
 ;
"RTN","XTMLOG1",18,0)
 ; 5th Argument (optional) a value of 1 if the variable(s) should be considered to be arrays and the values
"RTN","XTMLOG1",19,0)
 ;      of array elements should be displayed if they exist.
"RTN","XTMLOG1",20,0)
 ;
"RTN","XTMLOG1",21,0)
CONSOLEA(ROOT,INFO,MESSAGE,VARS,XTMLOARR) ;
"RTN","XTMLOG1",22,0)
 N GLOBREF,XTMLOGI S GLOBREF=$NA(^TMP("CONSOLEA",$J)) K @GLOBREF
"RTN","XTMLOG1",23,0)
 D SETLINES(GLOBREF,ROOT,.INFO,MESSAGE,$G(VARS),$G(XTMLOARR))
"RTN","XTMLOG1",24,0)
 F XTMLOGI=0:0 S XTMLOGI=$O(@GLOBREF@(XTMLOGI)) Q:XTMLOGI'>0  W !,@GLOBREF@(XTMLOGI)
"RTN","XTMLOG1",25,0)
 Q
"RTN","XTMLOG1",26,0)
 ;
"RTN","XTMLOG1",27,0)
ROLLINGF(ROOT,INFO,MESSAGE) ;
"RTN","XTMLOG1",28,0)
 Q
"RTN","XTMLOG1",29,0)
 ;
"RTN","XTMLOG1",30,0)
DAILYROL(ROOT,INFO,MESSAGE) ;
"RTN","XTMLOG1",31,0)
 Q
"RTN","XTMLOG1",32,0)
 ;
"RTN","XTMLOG1",33,0)
GLOBAL(ROOT,INFO,MESSAGE,VARS,XTMLOARR) ;
"RTN","XTMLOG1",34,0)
 N GLOBREF,XTMLOGI
"RTN","XTMLOG1",35,0)
 S GLOBREF=$NA(^TMP("XTMLGLOB",$J)) K @GLOBREF
"RTN","XTMLOG1",36,0)
 D SETLINES(GLOBREF,ROOT,.INFO,MESSAGE,$G(VARS),$G(XTMLOARR))
"RTN","XTMLOG1",37,0)
 N XTMLOGDT S XTMLOGDT=$$GETDATE(.INFO,"{yyMMdd.HHmmss")
"RTN","XTMLOG1",38,0)
 S:INFO("LOCATION")="" INFO("LOCATION")=" "
"RTN","XTMLOG1",39,0)
 F XTMLOGI=0:0 S XTMLOGI=$O(@GLOBREF@(XTMLOGI)) Q:XTMLOGI'>0  S @(@ROOT@("CLOSEDROOT"))@(XTMLOGDT,INFO("COUNT"),INFO("LOCATION"),XTMLOGI)=@GLOBREF@(XTMLOGI)
"RTN","XTMLOG1",40,0)
 Q
"RTN","XTMLOG1",41,0)
 ;
"RTN","XTMLOG1",42,0)
SOCKETAP(ROOT,INFO,MESSAGE) ;
"RTN","XTMLOG1",43,0)
 S ^TMP("XTMLOSKT","DATA",@ROOT@("PORT"),$J,INFO("COUNT"))=$$FORMAT(ROOT,.INFO,MESSAGE)
"RTN","XTMLOG1",44,0)
 Q
"RTN","XTMLOG1",45,0)
 ;
"RTN","XTMLOG1",46,0)
SETLINES(XTMLGLOB,ROOT,INFO,MESSAGE,VARS,XTMLOARR) ; returns lines for output in XTMLGLOB
"RTN","XTMLOG1",47,0)
 N XTMLOGI,XTMLOGJ,XTMLOGVR,XTMLOCHR,XTMLOCNT,XTMLOPAR,XTMLOQUO,XTMLOSRT,VARDATA,VARDATAQ,XTMLBASE
"RTN","XTMLOG1",48,0)
 K @XTMLGLOB
"RTN","XTMLOG1",49,0)
 S XTMLBASE=$$FORMAT(ROOT,.INFO,MESSAGE)
"RTN","XTMLOG1",50,0)
 S XTMLOPAR=0,XTMLOQUO=0,XTMLOCNT=0,XTMLOSRT=1
"RTN","XTMLOG1",51,0)
 I $G(VARS)="" S @XTMLGLOB@(1)=XTMLBASE Q
"RTN","XTMLOG1",52,0)
 S XTMLOARR=+$G(XTMLOARR)
"RTN","XTMLOG1",53,0)
 F XTMLOGI=1:1 S XTMLOCHR=$E(VARS,XTMLOGI) Q:XTMLOCHR=""  D
"RTN","XTMLOG1",54,0)
 . S:XTMLOCHR="(" XTMLOPAR=XTMLOPAR+1 S:XTMLOCHR=")" XTMLOPAR=XTMLOPAR-1 S:XTMLOCHR="""" XTMLOQUO=$S(XTMLOQUO=0:1,1:0) I XTMLOPAR=0,XTMLOQUO=0,XTMLOCHR="," S XTMLOCNT=XTMLOCNT+1,VARS(XTMLOCNT)=$E(VARS,XTMLOSRT,XTMLOGI-1),XTMLOSRT=XTMLOGI+1
"RTN","XTMLOG1",55,0)
 . Q
"RTN","XTMLOG1",56,0)
 I XTMLOGI>XTMLOSRT S XTMLOCNT=XTMLOCNT+1,VARS(XTMLOCNT)=$E(VARS,XTMLOSRT,XTMLOGI)
"RTN","XTMLOG1",57,0)
 S XTMLOCNT=0
"RTN","XTMLOG1",58,0)
 F XTMLOGI=1:1 Q:'$D(VARS(XTMLOGI))  S XTMLOGVR=VARS(XTMLOGI) S XTMLOCNT=XTMLOCNT+1,@XTMLGLOB@(XTMLOCNT)=XTMLBASE_" - "_VARS(XTMLOGI)_": "_$S($D(@VARS(XTMLOGI))#2:@VARS(XTMLOGI),1:"<undefined>") I XTMLOARR D
"RTN","XTMLOG1",59,0)
 . S VARDATA=VARS(XTMLOGI) I $D(@VARDATA)>1 D
"RTN","XTMLOG1",60,0)
 . . S VARDATAQ=$S($E(VARDATA,$L(VARDATA))=")":$E(VARDATA,1,$L(VARDATA)-1),1:"")
"RTN","XTMLOG1",61,0)
 . . F XTMLOGJ=1:1 S VARDATA=$Q(@(VARDATA)) Q:VARDATA=""  Q:((VARDATAQ'="")&(VARDATA'[VARDATAQ))  S XTMLOCNT=XTMLOCNT+1,@XTMLGLOB@(XTMLOCNT)=XTMLBASE_" - "_VARDATA_": "_$S($D(@VARDATA)#2:@VARDATA,1:"<undefined>")
"RTN","XTMLOG1",62,0)
 . . Q
"RTN","XTMLOG1",63,0)
 . Q
"RTN","XTMLOG1",64,0)
 Q
"RTN","XTMLOG1",65,0)
 ;
"RTN","XTMLOG1",66,0)
FORMAT(ROOT,INFO,MESSAGE) ; Generate Formatted message
"RTN","XTMLOG1",67,0)
 N XTMLOGX,FRMT,LJUST,MINWID,CATEGORY,PREC,DATESTR
"RTN","XTMLOG1",68,0)
 S XTMLOGX="",FRMT=$G(@ROOT@("LAYOUT.CONVERSIONPATTERN"))
"RTN","XTMLOG1",69,0)
 ; anything before % is actual text
"RTN","XTMLOG1",70,0)
 F  Q:FRMT=""  S XTMLOGX=XTMLOGX_$P(FRMT,"%"),FRMT=$P(FRMT,"%",2,99) D
"RTN","XTMLOG1",71,0)
 . I $E(FRMT)="%" S XTMLOGX=XTMLOGX_"%",FRMT=$$RESTOF(FRMT) Q  ; %% yields %
"RTN","XTMLOG1",72,0)
 . S LJUST=$S($E(FRMT)="-":1,1:0) I LJUST S FRMT=$$RESTOF(FRMT) ; - left justify
"RTN","XTMLOG1",73,0)
 . S MINWID="" F  Q:'(FRMT?1N.E)  S MINWID=MINWID_$E(FRMT),FRMT=$$RESTOF(FRMT) ; digits min width
"RTN","XTMLOG1",74,0)
 . S MINWID=+MINWID
"RTN","XTMLOG1",75,0)
 . I $E(FRMT)="n" S FRMT=$$RESTOF(FRMT) Q  ; end of line
"RTN","XTMLOG1",76,0)
 . I $E(FRMT)="c" S FRMT=$$RESTOF(FRMT),PREC=$$GETPREC(.FRMT),CATEGORY=$G(INFO("CATEGORY")) S:PREC>0 CATEGORY=$P(CATEGORY,".",$L(CATEGORY,".")-PREC+1,$L(CATEGORY,".")) S XTMLOGX=$$ADDTEXT(XTMLOGX,LJUST,MINWID,CATEGORY) Q
"RTN","XTMLOG1",77,0)
 . I $E(FRMT)="p" S FRMT=$$RESTOF(FRMT),XTMLOGX=$$ADDTEXT(XTMLOGX,LJUST,MINWID,$G(INFO("PRIORITY"))) Q
"RTN","XTMLOG1",78,0)
 . I $E(FRMT)="t" S FRMT=$$RESTOF(FRMT),XTMLOGX=$$ADDTEXT(XTMLOGX,LJUST,MINWID,$J) Q
"RTN","XTMLOG1",79,0)
 . I $E(FRMT)="m" S FRMT=$$RESTOF(FRMT),XTMLOGX=$$ADDTEXT(XTMLOGX,LJUST,MINWID,MESSAGE) Q
"RTN","XTMLOG1",80,0)
 . I $E(FRMT)="L" S FRMT=$$RESTOF(FRMT),XTMLOGX=$$ADDTEXT(XTMLOGX,LJUST,MINWID,$P($G(INFO("LOCATION")),U)) Q
"RTN","XTMLOG1",81,0)
 . I $E(FRMT)="M" S FRMT=$$RESTOF(FRMT),XTMLOGX=$$ADDTEXT(XTMLOGX,LJUST,MINWID,$P($P($G(INFO("LOCATION")),U),"+")) Q
"RTN","XTMLOG1",82,0)
 . I $E(FRMT)="F" S FRMT=$$RESTOF(FRMT),XTMLOGX=$$ADDTEXT(XTMLOGX,LJUST,MINWID,$P($G(INFO("LOCATION")),U,2)) Q
"RTN","XTMLOG1",83,0)
 . I $E(FRMT)="d" S FRMT=$$RESTOF(FRMT),DATESTR=$$GETDATE(.INFO,.FRMT),XTMLOGX=$$ADDTEXT(XTMLOGX,LJUST,MINWID,DATESTR) Q
"RTN","XTMLOG1",84,0)
 . S FRMT=$$RESTOF(FRMT) ; if unknown, just remove
"RTN","XTMLOG1",85,0)
 . Q
"RTN","XTMLOG1",86,0)
 Q XTMLOGX
"RTN","XTMLOG1",87,0)
 ;
"RTN","XTMLOG1",88,0)
RESTOF(X) ;
"RTN","XTMLOG1",89,0)
 Q $E(X,2,$L(X))
"RTN","XTMLOG1",90,0)
 ;
"RTN","XTMLOG1",91,0)
GETDATE(INFO,X) ; INFO and X are passed by refernce
"RTN","XTMLOG1",92,0)
 N FRMT,DATEVAL,X1,FMDATE
"RTN","XTMLOG1",93,0)
 I $E(X)="{" S X=$$RESTOF(X) S FRMT=$$DATEFRMT(.X)
"RTN","XTMLOG1",94,0)
 E  S FRMT="yyyyMMdd.HHmmss"
"RTN","XTMLOG1",95,0)
 I FRMT'="" S FMDATE=$$HTFM^XLFDT(INFO("$H"))
"RTN","XTMLOG1",96,0)
 S DATEVAL="" F  Q:FRMT=""  S X1=$E(FRMT),FRMT=$$RESTOF(FRMT) D
"RTN","XTMLOG1",97,0)
 . I X1="y" S X1=$$YEAR(FMDATE,.FRMT)
"RTN","XTMLOG1",98,0)
 . I X1="M" S X1=$$MONTH(FMDATE,.FRMT)
"RTN","XTMLOG1",99,0)
 . I X1="d" S X1=$$DAY(FMDATE,.FRMT)
"RTN","XTMLOG1",100,0)
 . I X1="H" S X1=$$HOUR(FMDATE,.FRMT)
"RTN","XTMLOG1",101,0)
 . I X1="m" S X1=$$MIN(FMDATE,.FRMT)
"RTN","XTMLOG1",102,0)
 . I X1="s" S X1=$$SEC(FMDATE,.FRMT)
"RTN","XTMLOG1",103,0)
 . I X1="S" S X1=$$MILLISEC(FMDATE,.FRMT)
"RTN","XTMLOG1",104,0)
 . S DATEVAL=DATEVAL_X1
"RTN","XTMLOG1",105,0)
 . Q
"RTN","XTMLOG1",106,0)
 Q DATEVAL
"RTN","XTMLOG1",107,0)
 ;
"RTN","XTMLOG1",108,0)
DATEFRMT(X) ; X is passed by reference
"RTN","XTMLOG1",109,0)
 N XVAL,X1 S XVAL=""
"RTN","XTMLOG1",110,0)
 F  Q:X=""  S X1=$E(X),X=$$RESTOF(X) S:X1'="}" XVAL=XVAL_X1 I X1="}" Q
"RTN","XTMLOG1",111,0)
 Q XVAL
"RTN","XTMLOG1",112,0)
 ;
"RTN","XTMLOG1",113,0)
ADDTEXT(STR,LJUST,MINWID,NEW) ;
"RTN","XTMLOG1",114,0)
 N FILL
"RTN","XTMLOG1",115,0)
 I MINWID>0 S $P(FILL," ",MINWID)=" "
"RTN","XTMLOG1",116,0)
 I $L(NEW)<MINWID D
"RTN","XTMLOG1",117,0)
 . I LJUST S NEW=NEW_FILL,NEW=$E(NEW,1,MINWID)
"RTN","XTMLOG1",118,0)
 . E  S NEW=FILL_NEW,NEW=$E(NEW,$L(NEW)-MINWID+1,$L(NEW))
"RTN","XTMLOG1",119,0)
 Q STR_NEW
"RTN","XTMLOG1",120,0)
 ;
"RTN","XTMLOG1",121,0)
GETPREC(X) ; X passed by reference
"RTN","XTMLOG1",122,0)
 ; dummy stub
"RTN","XTMLOG1",123,0)
 Q -1
"RTN","XTMLOG1",124,0)
 ;
"RTN","XTMLOG1",125,0)
YEAR(FMDATE,FRMT) ;
"RTN","XTMLOG1",126,0)
 N N
"RTN","XTMLOG1",127,0)
 S N=1 F  Q:$E(FRMT)'="y"  S N=N+1,FRMT=$$RESTOF(FRMT)
"RTN","XTMLOG1",128,0)
 Q $E($E(FMDATE,1,3)+1700,5-N,4)
"RTN","XTMLOG1",129,0)
 ;
"RTN","XTMLOG1",130,0)
MONTH(FMDATE,FRMT) ;
"RTN","XTMLOG1",131,0)
 N N,XVAL
"RTN","XTMLOG1",132,0)
 S N=1 F  Q:$E(FRMT)'="M"  S N=N+1,FRMT=$$RESTOF(FRMT)
"RTN","XTMLOG1",133,0)
 S XVAL=$E(FMDATE,4,5)
"RTN","XTMLOG1",134,0)
 I N=3 S XVAL=$P("JAN^FEB^MAR^APR^MAY^JUN^JUL^AUG^SEP^OCT^NOV^DEC",U,+XVAL)
"RTN","XTMLOG1",135,0)
 I N>3 S XVAL=$P("JANUARY^FEBRUARY^MARCH^APRIL^MAY^JUNE^JULY^AUGUST^SEPTEMBER^OCTOBER^NOVEMBER^DECEMBER",U,+XVAL)
"RTN","XTMLOG1",136,0)
 Q XVAL
"RTN","XTMLOG1",137,0)
 ;
"RTN","XTMLOG1",138,0)
DAY(FMDATE,FRMT) ;
"RTN","XTMLOG1",139,0)
 N N,XVAL
"RTN","XTMLOG1",140,0)
 S N=1 F  Q:$E(FRMT)'="d"  S N=N+1,FRMT=$$RESTOF(FRMT)
"RTN","XTMLOG1",141,0)
 S XVAL=$E(FMDATE,6,7)
"RTN","XTMLOG1",142,0)
 ;I N>2 S XVAL=$P
"RTN","XTMLOG1",143,0)
 Q XVAL
"RTN","XTMLOG1",144,0)
 ;
"RTN","XTMLOG1",145,0)
HOUR(FMDATE,FRMT) ;
"RTN","XTMLOG1",146,0)
 N N,XVAL
"RTN","XTMLOG1",147,0)
 S N=1 F  Q:$E(FRMT)'="H"  S N=N+1,FRMT=$$RESTOF(FRMT)
"RTN","XTMLOG1",148,0)
 S XVAL=$E(FMDATE_"OOO",9,10)
"RTN","XTMLOG1",149,0)
 I N=1 S FRMT=FRMT_$S(XVAL>12:" PM",1:" AM"),XVAL=$S(XVAL>12:XVAL-12,1:XVAL)
"RTN","XTMLOG1",150,0)
 Q XVAL
"RTN","XTMLOG1",151,0)
 ;
"RTN","XTMLOG1",152,0)
MIN(FMDATE,FRMT) ;
"RTN","XTMLOG1",153,0)
 N N,XVAL
"RTN","XTMLOG1",154,0)
 S N=1 F  Q:$E(FRMT)'="m"  S N=N+1,FRMT=$$RESTOF(FRMT)
"RTN","XTMLOG1",155,0)
 S XVAL=$E(FMDATE_"00000",11,12)
"RTN","XTMLOG1",156,0)
 I N=1 S XVAL=+XVAL
"RTN","XTMLOG1",157,0)
 Q XVAL
"RTN","XTMLOG1",158,0)
 ;
"RTN","XTMLOG1",159,0)
SEC(FMDATE,FRMT) ;
"RTN","XTMLOG1",160,0)
 N N,XVAL
"RTN","XTMLOG1",161,0)
 S N=1 F  Q:$E(FRMT)'="s"  S N=N+1,FRMT=$$RESTOF(FRMT)
"RTN","XTMLOG1",162,0)
 S XVAL=$E(FMDATE_"0000000",13,14)
"RTN","XTMLOG1",163,0)
 I N=1 S XVAL=+XVAL
"RTN","XTMLOG1",164,0)
 Q XVAL
"RTN","XTMLOG1",165,0)
 ;
"RTN","XTMLOG1",166,0)
MILLISEC(FMDATE,FRMT) ;
"RTN","XTMLOG1",167,0)
 ; NO WAY TO GET MILLISECONDS, JUST PUT NULLS
"RTN","XTMLOG1",168,0)
 F  Q:$E(FRMT)'="S"  S FRMT=$$RESTOF(FRMT)
"RTN","XTMLOG1",169,0)
 Q ""
"RTN","XTMLOG2")
1^5
"RTN","XTMLOPAR")
0^6^B19404303
"RTN","XTMLOPAR",1,0)
XTMLOPAR ;JLI/FO-OAK - HANDLE PARSING FOR LOG4M XML CONFIGURATION FILE ;06/07/08  17:05
"RTN","XTMLOPAR",2,0)
 ;;7.3;TOOLKIT;**81**;Apr 25, 1995;Build 18
"RTN","XTMLOPAR",3,0)
 ;;Per VHA Directive 2004-038, this routine should not be modified
"RTN","XTMLOPAR",4,0)
 Q
"RTN","XTMLOPAR",5,0)
ENTRY(XTMNAME,GLOBROOT,RESULTS) ; RESULTS is passed by reference
"RTN","XTMLOPAR",6,0)
 S ELNUM=0,COUNT=0,APPCOUNT=0,GLOROOT=$NA(^TMP("JLIXML",$J)),GLOROOT(0)=GLOROOT K @GLOROOT
"RTN","XTMLOPAR",7,0)
 S ARRAY("STARTDOCUMENT")="STARTDOC^XTMLOPAR",ARRAY("ENDDOCUMENT")="ENDDOC^XTMLOPAR"
"RTN","XTMLOPAR",8,0)
 S ARRAY("DOCTYPE")="DOCTYPE^XTMLOPAR",ARRAY("STARTELEMENT")="STARTEL^XTMLOPAR"
"RTN","XTMLOPAR",9,0)
 S ARRAY("ENDELEMENT")="ENDEL^XTMLOPAR",ARRAY("CHARACTERS")="CHARS^XTMLOPAR"
"RTN","XTMLOPAR",10,0)
 S ARRAY("PI")="PI^XTMLOPAR",ARRAY("NOTATION")="NOTATION^XTMLOPAR"
"RTN","XTMLOPAR",11,0)
 S ARRAY("EXTERNAL")="EXTERNAL^XTMLOPAR",ARRAY("COMMENT")="COMMENT^XTMLOPAR",ARRAY("ERROR")="ERROR^XTMLOPAR"
"RTN","XTMLOPAR",12,0)
 D EN^MXMLPRSE(GLOBROOT,.ARRAY,"V")
"RTN","XTMLOPAR",13,0)
 Q
"RTN","XTMLOPAR",14,0)
 ;
"RTN","XTMLOPAR",15,0)
STARTDOC ; STARTDOCUMENT
"RTN","XTMLOPAR",16,0)
 W !,"START DOC ENTRY"
"RTN","XTMLOPAR",17,0)
 Q
"RTN","XTMLOPAR",18,0)
 ;
"RTN","XTMLOPAR",19,0)
ENDDOC ; ENDDOCUMENT
"RTN","XTMLOPAR",20,0)
 W !,"END DOC ENTRY"
"RTN","XTMLOPAR",21,0)
 Q
"RTN","XTMLOPAR",22,0)
 ;
"RTN","XTMLOPAR",23,0)
DOCTYPE(ROOT,PUBID,SYSID) ; DOCTYPE
"RTN","XTMLOPAR",24,0)
 W !,"DOCTYPE ENTRY"
"RTN","XTMLOPAR",25,0)
 W !,"ROOT=",ROOT,"  PUBID=",PUBID,"  SYSID=",SYSID
"RTN","XTMLOPAR",26,0)
 Q
"RTN","XTMLOPAR",27,0)
 ;
"RTN","XTMLOPAR",28,0)
STARTEL(NAME,ATTRIBS) ; STARTELEMENT
"RTN","XTMLOPAR",29,0)
 ;W !,"START ELEMENT ",NAME,! ZW ATTRIBS
"RTN","XTMLOPAR",30,0)
 S ELNUM=$G(ELNUM)+1
"RTN","XTMLOPAR",31,0)
 S COUNT=COUNT+1
"RTN","XTMLOPAR",32,0)
 S GLOROOT(ELNUM)=$NA(@GLOROOT(ELNUM-1)@(NAME,COUNT))
"RTN","XTMLOPAR",33,0)
 S A="" F  S A=$O(ATTRIBS(A)) Q:A=""  S @GLOROOT(ELNUM)@(A)=ATTRIBS(A)
"RTN","XTMLOPAR",34,0)
 S FLAG=$G(FLAG),PARAMFLG=""
"RTN","XTMLOPAR",35,0)
 I $$UP^XLFSTR(NAME)="ROOT" S FLAG="ROOT"
"RTN","XTMLOPAR",36,0)
 I $$UP^XLFSTR(NAME)="APPENDER" S FLAG="APPENDER",APPNAME=""
"RTN","XTMLOPAR",37,0)
 I $$UP^XLFSTR(NAME)="PARAM" S PARAMFLG=1
"RTN","XTMLOPAR",38,0)
 I FLAG="ROOT" D ROOT(NAME,.ATTRIBS)
"RTN","XTMLOPAR",39,0)
 I FLAG="APPENDER" D APPENDER(NAME,.ATTRIBS)
"RTN","XTMLOPAR",40,0)
 Q
"RTN","XTMLOPAR",41,0)
 ;
"RTN","XTMLOPAR",42,0)
ENDEL(NAME) ; ENDELEMENT
"RTN","XTMLOPAR",43,0)
 W !,"END ELEMENT ",NAME
"RTN","XTMLOPAR",44,0)
 K GLOROOT(ELNUM)
"RTN","XTMLOPAR",45,0)
 S ELNUM=ELNUM-1
"RTN","XTMLOPAR",46,0)
 Q
"RTN","XTMLOPAR",47,0)
 ;
"RTN","XTMLOPAR",48,0)
CHARS(TEXT) ; CHARACTERS
"RTN","XTMLOPAR",49,0)
 ;W !,"IN CHARS: ",TEXT
"RTN","XTMLOPAR",50,0)
 Q
"RTN","XTMLOPAR",51,0)
 ;
"RTN","XTMLOPAR",52,0)
PI(TARGET,TEXT) ; PI
"RTN","XTMLOPAR",53,0)
 ;W !,"IN PI: TARGET=",TARGET,"  TEXT=",TEXT
"RTN","XTMLOPAR",54,0)
 Q
"RTN","XTMLOPAR",55,0)
 ;
"RTN","XTMLOPAR",56,0)
NOTATION(NAME,SYSID,PUBIC) ; NOTATION
"RTN","XTMLOPAR",57,0)
 ;W !,"IN NOTATION, NAME=",NAME,"  SYSID=,$G(SYSID),"  PUBIC=",$G(PUBIC)
"RTN","XTMLOPAR",58,0)
 Q
"RTN","XTMLOPAR",59,0)
 ;
"RTN","XTMLOPAR",60,0)
EXTERNAL(SYSID,PUBID,GLOBAL) ; EXTERNAL
"RTN","XTMLOPAR",61,0)
 ;W !,"IN EXTERNAL SYSID=",$G(SYSID),"  PUBID=",$G(PUBID),"  GLOBAL=",$G(GLOBAL)
"RTN","XTMLOPAR",62,0)
 S PUBID=SYSID,SYSID=""
"RTN","XTMLOPAR",63,0)
 Q
"RTN","XTMLOPAR",64,0)
 ;
"RTN","XTMLOPAR",65,0)
COMMENT(TEXT) ; COMMENT
"RTN","XTMLOPAR",66,0)
 ;W !,"IN COMMENT: TEXT=",TEXT
"RTN","XTMLOPAR",67,0)
 Q
"RTN","XTMLOPAR",68,0)
 ;
"RTN","XTMLOPAR",69,0)
ERROR(ERR) ; ERROR - ERR is a local array
"RTN","XTMLOPAR",70,0)
 ;W !,"IN ERROR",! ZW ERR
"RTN","XTMLOPAR",71,0)
 Q
"RTN","XTMLOPAR",72,0)
 ;
"RTN","XTMLOPAR",73,0)
ROOT(NAME,ATTRIBS) ;
"RTN","XTMLOPAR",74,0)
 N ATTNAME,COUNT
"RTN","XTMLOPAR",75,0)
 ;W !,"IN ROOT: NAME=",NAME,! ZW ATTRIBS
"RTN","XTMLOPAR",76,0)
 S ATTNAME="",COUNT=0 F  S ATTNAME=$O(ATTRIBS(ATTNAME)) Q:ATTNAME=""  S COUNT=COUNT+1,XNAME(COUNT)=ATTNAME
"RTN","XTMLOPAR",77,0)
 I COUNT=1 S RESULTS(XTMNAME,$$UP^XLFSTR(NAME))=$$UP^XLFSTR(ATTRIBS(XNAME(1)))
"RTN","XTMLOPAR",78,0)
 Q
"RTN","XTMLOPAR",79,0)
 ;
"RTN","XTMLOPAR",80,0)
APPENDER(NAME,ATTRIBS) ;
"RTN","XTMLOPAR",81,0)
 I APPNAME="" D  Q
"RTN","XTMLOPAR",82,0)
 . S ATTNAME="" F  S ATTNAME=$O(ATTRIBS(ATTNAME)) Q:ATTNAME=""  I $$UP^XLFSTR(ATTNAME)="NAME" S APPCOUNT=APPCOUNT+1,APPNAME=APPCOUNT,RESULTS(XTMNAME,"APPENDER",APPNAME,"TYPE")=$$UP^XLFSTR(ATTRIBS(ATTNAME))
"RTN","XTMLOPAR",83,0)
 . I APPNAME'="" S ATTNAME="" F  S ATTNAME=$O(ATTRIBS(ATTNAME)) Q:ATTNAME=""  I $$UP^XLFSTR(ATTNAME)'="NAME" S RESULTS(XTMNAME,"APPENDER",APPNAME,$$UP^XLFSTR(ATTNAME))=$$UP^XLFSTR(ATTRIBS(ATTNAME))
"RTN","XTMLOPAR",84,0)
 . Q
"RTN","XTMLOPAR",85,0)
 ; now parameters
"RTN","XTMLOPAR",86,0)
 I PARAMFLG D  Q
"RTN","XTMLOPAR",87,0)
 . S ATTNAME="",XNAME="",XVALUE="" F  S ATTNAME=$O(ATTRIBS(ATTNAME)) Q:ATTNAME=""  S:$$UP^XLFSTR(ATTNAME)="NAME" XNAME=ATTNAME S:$$UP^XLFSTR(ATTNAME)="VALUE" XVALUE=ATTNAME
"RTN","XTMLOPAR",88,0)
 . I XNAME'="",XVALUE'="" S RESULTS(XTMNAME,"APPENDER",APPNAME,$$UP^XLFSTR(ATTRIBS(XNAME)))=$$UP^XLFSTR(ATTRIBS(XVALUE))
"RTN","XTMLOPAR",89,0)
 . Q
"RTN","XTMLOPAR",90,0)
 E  D DEBUG^XTMLOG("IN APPENDER WITH NO FLAG")
"RTN","XTMLOPAR",91,0)
 Q
"RTN","XTMLOPAR",92,0)
 ;
"RTN","XTMLOPAR",93,0)
LOADGLOB ; Load input (pasted) text into a global
"RTN","XTMLOPAR",94,0)
 N XGLOB,COUNT,X
"RTN","XTMLOPAR",95,0)
 W !,"Paste your text.  When there are no more lines within 5 seconds, it will finish.",!,":"
"RTN","XTMLOPAR",96,0)
 S XGLOB=$NA(^TMP("XTMLOAD",$J)) K @XGLOB
"RTN","XTMLOPAR",97,0)
 S COUNT=0 F  R X:5 Q:'$T  W ! D
"RTN","XTMLOPAR",98,0)
 . F  Q:$E(X,$L(X))'=" "  S X=$E(X,1,$L(X)-1) ; remove trailing spaces
"RTN","XTMLOPAR",99,0)
 . I X'="" S COUNT=COUNT+1,@XGLOB@(COUNT)=X ; skip null lines and store text
"RTN","XTMLOPAR",100,0)
 . Q
"RTN","XTMLOPAR",101,0)
 W !!,COUNT," lines input and stored under ",XGLOB
"RTN","XTMLOPAR",102,0)
 Q
"RTN","XTMLOSKT")
0^7^B36861478
"RTN","XTMLOSKT",1,0)
XTMLOSKT ;SLC/KCM;OAK/JLI - Socket Appender borrowed from XWBTCPL ;06/07/08  17:02
"RTN","XTMLOSKT",2,0)
 ;;7.3;T0OLKIT;**81**;Apr 25, 1995;Build 18
"RTN","XTMLOSKT",3,0)
 ;;Per VHA Directive 2004-038, this routine should not be modified
"RTN","XTMLOSKT",4,0)
 ;ISC-SF/EG - DHCP Broker
"RTN","XTMLOSKT",5,0)
 ;
"RTN","XTMLOSKT",6,0)
 ; This routine is the background process that listens for client
"RTN","XTMLOSKT",7,0)
 ; requests to connect to M.  When a request is received, This
"RTN","XTMLOSKT",8,0)
 ; procedure will job a routine to handle the requests of the client.
"RTN","XTMLOSKT",9,0)
 ;
"RTN","XTMLOSKT",10,0)
 ; This job may be started in the background with:  D STRT^XWBTCP(PORT)
"RTN","XTMLOSKT",11,0)
 ;
"RTN","XTMLOSKT",12,0)
 ; When running, this job may be stopped with:      D STOP^XWBTCP(PORT)
"RTN","XTMLOSKT",13,0)
 ;
"RTN","XTMLOSKT",14,0)
 ; Where port is the known service port to listen for connections
"RTN","XTMLOSKT",15,0)
 ;
"RTN","XTMLOSKT",16,0)
EN(XWBTSKT) ; -- accept clients and start the individual message handler
"RTN","XTMLOSKT",17,0)
 ;N $ETRAP,$ESTACK S $ETRAP="D ^%ZTER J EN^XTMLOSKT($G(XWBTSKT)) HALT"
"RTN","XTMLOSKT",18,0)
 N RETRY,X,XWBVER,XWBVOL,LEN,MSG,XWBOS,DONE,DSMTCP,NATIP
"RTN","XTMLOSKT",19,0)
 S U="^",RETRY="START"
"RTN","XTMLOSKT",20,0)
 X ^%ZOSF("UCI") S XWBVOL=$P(Y,",",2) ;(*p7,p9*)
"RTN","XTMLOSKT",21,0)
 IF $G(XWBTSKT)="" S XWBTSKT=9400 ; default service port
"RTN","XTMLOSKT",22,0)
 S XWBTDEV=XWBTSKT
"RTN","XTMLOSKT",23,0)
 ;
"RTN","XTMLOSKT",24,0)
 Q:'$$SEMAPHOR(XWBTSKT,"LOCK")  ; -- quit if job is already running
"RTN","XTMLOSKT",25,0)
 ;
"RTN","XTMLOSKT",26,0)
 S XWBDEBUG=$$GET^XPAR("SYS","XWBDEBUG")
"RTN","XTMLOSKT",27,0)
 I XWBDEBUG D LOGSTART^XWBDLOG("XTMLOSKT")
"RTN","XTMLOSKT",28,0)
 D UPDTREC(XWBTSKT,3) ;updt RPC BROKER SITE PARAMETER record as RUNNING
"RTN","XTMLOSKT",29,0)
 D MARKER^XWBTCP(XWBTSKT,-1) ;Clear marker
"RTN","XTMLOSKT",30,0)
 ;
"RTN","XTMLOSKT",31,0)
 H 2 ;Hibernate so caller can clear (*p16)
"RTN","XTMLOSKT",32,0)
 D SETNM^%ZOSV($E("XTML_Port:"_XWBTSKT,1,15)) ;change process name
"RTN","XTMLOSKT",33,0)
 S ^TMP("XTMLOSKT","$J",$J)=""
"RTN","XTMLOSKT",34,0)
 ;
"RTN","XTMLOSKT",35,0)
RESTART ;
"RTN","XTMLOSKT",36,0)
 N $ESTACK S $ETRAP="D ETRAP^XTMLOSKT"
"RTN","XTMLOSKT",37,0)
 S DONE=0,X=0
"RTN","XTMLOSKT",38,0)
 S XWBOS=$S(^%ZOSF("OS")["DSM":"DSM",^("OS")["OpenM":"OpenM",^("OS")["GT.M":"GTM",^("OS")["MSM":"MSM",1:"")
"RTN","XTMLOSKT",39,0)
 ;
"RTN","XTMLOSKT",40,0)
 S %T=0,IOF="!" ;Check for Open success (*p35)
"RTN","XTMLOSKT",41,0)
 I XWBOS="DSM" O XWBTSKT:TCPCHAN:5 S %T=$T ;Open listener
"RTN","XTMLOSKT",42,0)
 I XWBOS="OpenM" S XWBTDEV="|TCP|"_XWBTSKT O XWBTDEV:(:XWBTSKT:"AT"::512:512:10):5 S %T=$T ;512 buffers, queue = 10 (*p35)
"RTN","XTMLOSKT",43,0)
 I XWBOS="GTM" D
"RTN","XTMLOSKT",44,0)
 . S @("$ZINTERRUPT=""I $$JOBEXAM^ZU($ZPOSITION)""")
"RTN","XTMLOSKT",45,0)
 . S XWBTDEV="SKD$"_$J,XWBTSKT=XWBTSKT,IOF="#"
"RTN","XTMLOSKT",46,0)
 . O XWBTDEV:(ZLISTEN=XWBTSKT_":TCP":ATTACH="listener"):5:"SOCKET" ;S %T=$T Q:'%T
"RTN","XTMLOSKT",47,0)
 . U XWBTDEV S XWBTDEV("LISTENER")=$KEY
"RTN","XTMLOSKT",48,0)
 . W /LISTEN(1)
"RTN","XTMLOSKT",49,0)
 . U XWBTDEV S XWBTDEV("STATUS")=$KEY
"RTN","XTMLOSKT",50,0)
 . Q
"RTN","XTMLOSKT",51,0)
 ;
"RTN","XTMLOSKT",52,0)
 I XWBDEBUG D LOG^XWBTCPC("Port Open: "_XWBTSKT)
"RTN","XTMLOSKT",53,0)
 F  D  Q:DONE
"RTN","XTMLOSKT",54,0)
 . ; -- listen for connect & get the initial message from the client
"RTN","XTMLOSKT",55,0)
 . I XWBOS="DSM" U XWBTSKT
"RTN","XTMLOSKT",56,0)
 . I XWBOS="MSM" S XWBTDEV=56 O 56 U 56::"TCP" W /SOCKET("",XWBTSKT)
"RTN","XTMLOSKT",57,0)
 . I XWBOS="OpenM" U XWBTDEV R *X
"RTN","XTMLOSKT",58,0)
 . I XWBOS="GTM" D
"RTN","XTMLOSKT",59,0)
 . . K XWBTDEV("SOCKET")
"RTN","XTMLOSKT",60,0)
 . . F  D  Q:$D(XWBTDEV("SOCKET"))
"RTN","XTMLOSKT",61,0)
 . . . ;Wait for connection, $KEY will be "CONNECT|socket_handle|remote_ipaddress"
"RTN","XTMLOSKT",62,0)
 . . . U XWBTDEV W /WAIT(10) S XWBTDEV("KEY")=$KEY
"RTN","XTMLOSKT",63,0)
 . . . I XWBTDEV("KEY")="" Q
"RTN","XTMLOSKT",64,0)
 . . . S XWBTDEV("SOCKET")=$P(XWBTDEV("KEY"),"|",2)
"RTN","XTMLOSKT",65,0)
 . . . S (XWBTDEV("IP"),IO("GTM-IP"))=$P(XWBTDEV("KEY"),"|",3)
"RTN","XTMLOSKT",66,0)
 . . . U XWBTDEV:(SOCKET=XWBTDEV("SOCKET"):WIDTH=512:NOWRAP:EXCEPTION="GOTO ETRAP")
"RTN","XTMLOSKT",67,0)
 . . . Q
"RTN","XTMLOSKT",68,0)
 . . Q
"RTN","XTMLOSKT",69,0)
 . I $D(^TMP("XTMLOSKT","DATA",XWBTSKT)) D
"RTN","XTMLOSKT",70,0)
 . . U XWBTSKT
"RTN","XTMLOSKT",71,0)
 . . D FLUSH
"RTN","XTMLOSKT",72,0)
 . . N I,X S JOB="" F  Q:DONE  S JOB=$O(^TMP("XTMLOSKT","DATA",XWBTSKT,JOB)) Q:JOB=""  F I=0:0 S I=$O(^TMP("XTMLOSKT","DATA",XWBTSKT,JOB,I)) Q:I'>0  D
"RTN","XTMLOSKT",73,0)
 . . . S X=^TMP("XTMLOSKT","DATA",XWBTSKT,JOB,I) K ^(I) D
"RTN","XTMLOSKT",74,0)
 . . . . N $ETRAP,$ESTACK S $ETRAP="D IGNOR^XTMLOSKT"
"RTN","XTMLOSKT",75,0)
 . . . . W X,$C(13,10),@IOF I $D(^TMP("XTMLOSKT","STOP",XWBTSKT)) S DONE=1 K ^(XWBTSKT)
"RTN","XTMLOSKT",76,0)
 . . . Q
"RTN","XTMLOSKT",77,0)
 . . Q
"RTN","XTMLOSKT",78,0)
 . H 1
"RTN","XTMLOSKT",79,0)
 . I $D(^TMP("XTMLOSKT","STOP",XWBTSKT)) S DONE=1 K ^(XWBTSKT)
"RTN","XTMLOSKT",80,0)
 . Q
"RTN","XTMLOSKT",81,0)
 ; -- loop end
"RTN","XTMLOSKT",82,0)
 ;
"RTN","XTMLOSKT",83,0)
 S %=$$SEMAPHOR(XWBTSKT,"UNLOCK") ; destroy 'running flag'
"RTN","XTMLOSKT",84,0)
 D UPDTREC(XWBTSKT,6) ;updt RPC BROKER SITE PARAMETER record as STOPPED
"RTN","XTMLOSKT",85,0)
 IF XWBOS="DSM" C XWBTSKT ;Do Close last in case it gets an error
"RTN","XTMLOSKT",86,0)
 Q
"RTN","XTMLOSKT",87,0)
IGNOR ;
"RTN","XTMLOSKT",88,0)
 S IGNOR=$G(IGNOR)+1
"RTN","XTMLOSKT",89,0)
 ; S ^TMP("XTMLOSKT","IGNOR",IGNOR)=$H
"RTN","XTMLOSKT",90,0)
 S $ET="",$EC=""
"RTN","XTMLOSKT",91,0)
 Q
"RTN","XTMLOSKT",92,0)
 ;
"RTN","XTMLOSKT",93,0)
 ;
"RTN","XTMLOSKT",94,0)
ETRAP ; -- on trapped error, send error info to client
"RTN","XTMLOSKT",95,0)
 N XWBERC,XWBERR ;S $ETRAP="D ^%ZTER J EN^XTMLOSKT($G(XWBTSKT)) HALT"
"RTN","XTMLOSKT",96,0)
 S XWBERC=$$EC^%ZOSV,XWBERR=$C(24)_"M  ERROR="_XWBERC_$C(13,10)_"LAST REF="_$$LGR^%ZOSV_$C(4)
"RTN","XTMLOSKT",97,0)
 S ECOUNT=$G(ECOUNT)+1
"RTN","XTMLOSKT",98,0)
 S ^TMP("XTMLOSKT","ETRAP",ECOUNT,$H)=XWBERR
"RTN","XTMLOSKT",99,0)
 I (XWBERC["WRITE")!(XWBERC["READ") S $ECODE="" Q  ;
"RTN","XTMLOSKT",100,0)
 D ^%ZTER ;Record error and clear $ECODE
"RTN","XTMLOSKT",101,0)
 I XWBERC["F-DUPLNAM" D  HALT
"RTN","XTMLOSKT",102,0)
 . S %=$$SEMAPHOR(XWBTSKT,"UNLOCK") ; destroy 'running flag'
"RTN","XTMLOSKT",103,0)
 . D UPDTREC(XWBTSKT,6) ;updt RPC BROKER SITE PARAMETER record as STOPPED
"RTN","XTMLOSKT",104,0)
 . Q
"RTN","XTMLOSKT",105,0)
 Q
"RTN","XTMLOSKT",106,0)
 ;
"RTN","XTMLOSKT",107,0)
FLUSH ;Flush the input buffer
"RTN","XTMLOSKT",108,0)
 F  R X:0 Q:'$T
"RTN","XTMLOSKT",109,0)
 Q
"RTN","XTMLOSKT",110,0)
 ;
"RTN","XTMLOSKT",111,0)
RELEASE(%) ;Now release the connection. (*p7*)
"RTN","XTMLOSKT",112,0)
 ;Parameter is zero to Release, one to Close
"RTN","XTMLOSKT",113,0)
 I XWBOS="DSM" D  Q  ;(*p35)
"RTN","XTMLOSKT",114,0)
 . I $G(%) C XWBTSKT Q
"RTN","XTMLOSKT",115,0)
 . U XWBTSKT:DISCONNECT ; release this socket
"RTN","XTMLOSKT",116,0)
 I XWBOS="OpenM" D  Q  ;(*p35)
"RTN","XTMLOSKT",117,0)
 . I $G(%) C XWBTDEV Q
"RTN","XTMLOSKT",118,0)
 . W *-3,*-2 ;Send any data and release the socket
"RTN","XTMLOSKT",119,0)
 I XWBOS="GTM" D  Q  ;(*p35)
"RTN","XTMLOSKT",120,0)
 . I $G(%) C XWBTDEV Q
"RTN","XTMLOSKT",121,0)
 . C XWBTDEV:(SOCKET=XWBTDEV("SOCKET")) ;release the socket
"RTN","XTMLOSKT",122,0)
 I XWBOS="MSM" C 56
"RTN","XTMLOSKT",123,0)
 Q
"RTN","XTMLOSKT",124,0)
 ;
"RTN","XTMLOSKT",125,0)
UPDTREC(XWBTSKT,STATE,XWBENV) ; -- update STATUS field and ^%ZIS X-ref of the
"RTN","XTMLOSKT",126,0)
 ;RPC BROKER SITE PARAMETER file
"RTN","XTMLOSKT",127,0)
 ;XWBTSKT: listener port
"RTN","XTMLOSKT",128,0)
 N C,XWBOXIEN,XWBPOIEN,XWBFDA
"RTN","XTMLOSKT",129,0)
 S C=",",U="^"
"RTN","XTMLOSKT",130,0)
 I $G(XWBENV)'="" S Y=XWBENV
"RTN","XTMLOSKT",131,0)
 E  D GETENV^%ZOSV ;get Y=UCI^VOL^NODE^BOXLOOKUP of current system
"RTN","XTMLOSKT",132,0)
 ;I STATE=3 S ^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,4),XWBTSKT)=$J
"RTN","XTMLOSKT",133,0)
 ;I STATE=6 K ^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,4),XWBTSKT)
"RTN","XTMLOSKT",134,0)
 ;
"RTN","XTMLOSKT",135,0)
 S XWBOXIEN=$$FIND1^DIC(8994.17,",1,","",$P(Y,U,4)) ;find rec for box
"RTN","XTMLOSKT",136,0)
 S XWBPOIEN=$$FIND1^DIC(8994.171,C_XWBOXIEN_",1,","",XWBTSKT)
"RTN","XTMLOSKT",137,0)
 D:XWBPOIEN>0  ;update STATUS field if entry was found
"RTN","XTMLOSKT",138,0)
 . D FDA^DILF(8994.171,XWBPOIEN_C_XWBOXIEN_C_1_C,1,"R",STATE,"XWBFDA")
"RTN","XTMLOSKT",139,0)
 . D FILE^DIE("","XWBFDA")
"RTN","XTMLOSKT",140,0)
 Q
"RTN","XTMLOSKT",141,0)
 ;
"RTN","XTMLOSKT",142,0)
 ;
"RTN","XTMLOSKT",143,0)
SEMAPHOR(XWBTSKT,XWBACT) ;Lock/Unlock listener semaphore
"RTN","XTMLOSKT",144,0)
 ;XWBTSKT: listener port, XWBACT: "LOCK" | "UNLOCK" action to perform
"RTN","XTMLOSKT",145,0)
 ;if LOCK is requested, it will be attempted with 1 sec timeout and if
"RTN","XTMLOSKT",146,0)
 ;lock was obtained RESULT will be 1, otherwise it will be 0.  For
"RTN","XTMLOSKT",147,0)
 ;unlock RESULT will always be 1.
"RTN","XTMLOSKT",148,0)
 N RESULT
"RTN","XTMLOSKT",149,0)
 S U="^",RESULT=1
"RTN","XTMLOSKT",150,0)
 D GETENV^%ZOSV ;get Y=UCI^VOL^NODE^BOXLOOKUP of current system
"RTN","XTMLOSKT",151,0)
 I XWBACT="LOCK" D
"RTN","XTMLOSKT",152,0)
 . L +^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,4),XWBTSKT):1
"RTN","XTMLOSKT",153,0)
 . S RESULT=$T
"RTN","XTMLOSKT",154,0)
 E  L -^%ZIS(8994.171,"RPCB Listener",$P(Y,U,2),$P(Y,U),$P(Y,U,4),XWBTSKT)
"RTN","XTMLOSKT",155,0)
 Q RESULT
"RTN","XTMLOSKT",156,0)
 ;
"RTN","XTMLOSKT",157,0)
NEWJOB() ;Check if OK to start a new job, Return 1 if OK, 0 if not OK.
"RTN","XTMLOSKT",158,0)
 N X,Y,J
"RTN","XTMLOSKT",159,0)
 S X=$O(^XTV(8989.3,1,4,"B",XWBVOL,0)),J=$S(X>0:^XTV(8989.3,1,4,X,0),1:"ROU^y^1")
"RTN","XTMLOSKT",160,0)
 I $D(^%ZOSF("ACTJ")) X ^("ACTJ") I $P(J,U,3),($P(J,U,3)'>Y) Q 0
"RTN","XTMLOSKT",161,0)
 Q 1
"RTN","XTMLOSKT",162,0)
 ;
"RTN","XTMLOSKT",163,0)
START(PORT) ;
"RTN","XTMLOSKT",164,0)
 J EN^XTMLOSKT(PORT)
"RTN","XTMLOSKT",165,0)
 Q
"RTN","XTMLOSKT",166,0)
 ;
"RTN","XTMLOSKT",167,0)
STOP(PORT) ;
"RTN","XTMLOSKT",168,0)
 S ^TMP("XTMLOSKT","STOP",PORT)=""
"RTN","XTMLOSKT",169,0)
 Q
"RTN","XTMLOSKT",170,0)
 ;
"RTN","XTMLOSKT",171,0)
SETDATA(STR,PORT,COUNT) ;
"RTN","XTMLOSKT",172,0)
 S PORT=$G(PORT,8025),OLDCOUNT=$G(COUNT,$G(OLDCOUNT))+1
"RTN","XTMLOSKT",173,0)
 S ^TMP("XTMLOSKT","DATA",PORT,$J,OLDCOUNT)=STR
"RTN","XTMLOSKT",174,0)
 Q
"RTN","XTMLOSKT",175,0)
 ;
"RTN","XTMRPRNT")
0^1^B1220842
"RTN","XTMRPRNT",1,0)
XTMRPRNT ;ISC-SF.SEA/JLI - ROUTINE LISTER ;11/23/09  15:55
"RTN","XTMRPRNT",2,0)
 ;;7.3;TOOLKIT;**101**;Apr 25, 1995;Build 18
"RTN","XTMRPRNT",3,0)
 ;;Per VHA Directive 2004-038, this routine should not be modified
"RTN","XTMRPRNT",4,0)
 ;
"RTN","XTMRPRNT",5,0)
ENTRY ;
"RTN","XTMRPRNT",6,0)
 N DIF,I,IOP,ROU,X,XCNP
"RTN","XTMRPRNT",7,0)
 ; ZEXCEPT: IOM - SYSTEM VARIABLE
"RTN","XTMRPRNT",8,0)
 N OLDIOM S OLDIOM=IOM
"RTN","XTMRPRNT",9,0)
 X ^%ZOSF("RSEL") Q:$O(^UTILITY($J,""))=""
"RTN","XTMRPRNT",10,0)
 R !,"ENTER RETURN TO START: ",X:300 Q:'$T
"RTN","XTMRPRNT",11,0)
 S IOP=";255;" D ^%ZIS Q:POP
"RTN","XTMRPRNT",12,0)
 S ROU=0
"RTN","XTMRPRNT",13,0)
 F  S ROU=$O(^UTILITY($J,ROU)) Q:ROU=""  D
"RTN","XTMRPRNT",14,0)
 . W !,"ZR"
"RTN","XTMRPRNT",15,0)
 . K ^TMP($J,0)
"RTN","XTMRPRNT",16,0)
 . S X=ROU,XCNP=0,DIF="^TMP($J,0," X ^%ZOSF("LOAD")
"RTN","XTMRPRNT",17,0)
 . F I=0:0 S I=$O(^TMP($J,0,I)) Q:I'>0  D
"RTN","XTMRPRNT",18,0)
 . . S X=^TMP($J,0,I,0)
"RTN","XTMRPRNT",19,0)
 . . S X=$P(X," ")_$C(9)_$P(X," ",2,999)
"RTN","XTMRPRNT",20,0)
 . . W !,X
"RTN","XTMRPRNT",21,0)
 . W !,"ZS ",ROU
"RTN","XTMRPRNT",22,0)
 W !
"RTN","XTMRPRNT",23,0)
 S IOP=";"_OLDIOM_";" D ^%ZIS ; restore original margin
"RTN","XTMRPRNT",24,0)
 Q
"RTN","XTMUNIT")
0^3^B208648286
"RTN","XTMUNIT",1,0)
XTMUNIT ;OAKLAND OIFO/JLI - MUNIT UNIT TESTING FOR M ROUTINES ;07/19/11  14:12
"RTN","XTMUNIT",2,0)
 ;;7.3;TOOLKIT;**81**;Apr 25, 1995;Build 18
"RTN","XTMUNIT",3,0)
 ;;Per VHA Directive 2004-038, this routine should not be modified
"RTN","XTMUNIT",4,0)
 ; 100622 JLI - corrected typo in comments where XTMUINPT was listed as XTMUINP
"RTN","XTMUNIT",5,0)
 ; 100622 JLI - removed a comment which indicated data could potentially be returned from the called routine
"RTN","XTMUNIT",6,0)
 ;              in the XTMUINPT array.
"RTN","XTMUNIT",7,0)
 ; 100622 JLI - added code to handle STARTUP and SHUTDOWN from GUI app
"RTN","XTMUNIT",8,0)
 ; 110719 JLI - modified separators in GUI handling from ^ to ~~^~~
"RTN","XTMUNIT",9,0)
 ;              in the variable XTGUISEP if using a newer version of the
"RTN","XTMUNIT",10,0)
 ;              GUI app (otherwise, it is simply set to ^) since results
"RTN","XTMUNIT",11,0)
 ;              with a series of ^ embedded disturbed the output reported
"RTN","XTMUNIT",12,0)
 Q
"RTN","XTMUNIT",13,0)
 ;
"RTN","XTMUNIT",14,0)
EN(XTMURNAM,XTMUVERB) ; .SR Entry point with primary test routine name, optional 1 for verbose output
"RTN","XTMUNIT",15,0)
 N XTMULIST,XTMUROU,XTMUNIT
"RTN","XTMUNIT",16,0)
 I $G(XTMUVERB)'=1 S XTMUVERB=0
"RTN","XTMUNIT",17,0)
 S XTMULIST=1,XTMUROU(XTMULIST)=XTMURNAM
"RTN","XTMUNIT",18,0)
 D SETUT
"RTN","XTMUNIT",19,0)
 D EN1(.XTMUROU,XTMULIST)
"RTN","XTMUNIT",20,0)
 Q
"RTN","XTMUNIT",21,0)
 ;
"RTN","XTMUNIT",22,0)
SETUT ;
"RTN","XTMUNIT",23,0)
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
"RTN","XTMUNIT",24,0)
 S XTMUNIT("IO")=IO,XTMUNIT("DEV")="",XTMUNIT("DEVN")="" F  S XTMUNIT("DEVN")=$O(^TMP("XUDEVICE",$J,XTMUNIT("DEVN"))) Q:XTMUNIT("DEVN")=""  I $G(^(XTMUNIT("DEVN"),"IO"))=IO S XTMUNIT("DEV")=^(0) Q
"RTN","XTMUNIT",25,0)
 I XTMUNIT("DEV")="" S XTMUNIT("DEV")="XTMUNIT DEVICE" D SAVDEV^%ZISUTL(XTMUNIT("DEV"))
"RTN","XTMUNIT",26,0)
 S XTMUNIT=1 ; set to identify unit test being run check with $$ISUTEST^XTMUNIT()
"RTN","XTMUNIT",27,0)
 Q
"RTN","XTMUNIT",28,0)
 ;
"RTN","XTMUNIT",29,0)
EN1(XTMUROU,XTMULIST) ;
"RTN","XTMUNIT",30,0)
 N XTMUERRL,XTMUK,XTMUI,XTMUJ,OLDIO,OLDIOFLG,OLDIONAM,XTMUSTRT
"RTN","XTMUNIT",31,0)
 ; ZEXCEPT: XTMUVERB   -- ARGUMENT TO EN
"RTN","XTMUNIT",32,0)
 ; ZEXCEPT: XTMUGUI      -- CONDITIONALLY DEFINED BY GUINEXT
"RTN","XTMUNIT",33,0)
 ; ZEXCEPT: XTMUNIT  -- NEWED IN EN
"RTN","XTMUNIT",34,0)
 S XTMUNIT("CURR")=0,XTMUNIT("ECNT")=0,XTMUNIT("FAIL")=0,XTMUNIT("CHK")=0,XTMUNIT("NENT")=0,XTMUNIT("ERRN")=0
"RTN","XTMUNIT",35,0)
 ; first get any tree of routines from this one
"RTN","XTMUNIT",36,0)
 D GETTREE(.XTMUROU,.XTMULIST)
"RTN","XTMUNIT",37,0)
 ; 070224 - following code added to allow one overall STARTUP code JLI
"RTN","XTMUNIT",38,0)
 F  S XTMUNIT("CURR")=XTMUNIT("CURR")+1 Q:'$D(XTMUROU(XTMUNIT("CURR")))  D  I $G(XTMUSTRT)'="" D @XTMUSTRT Q
"RTN","XTMUNIT",39,0)
 . I $T(@("STARTUP^"_XTMUROU(XTMUNIT("CURR"))))'="" S XTMUSTRT="STARTUP^"_XTMUROU(XTMUNIT("CURR"))
"RTN","XTMUNIT",40,0)
 . Q
"RTN","XTMUNIT",41,0)
 ; 070224 - end of addition JLI
"RTN","XTMUNIT",42,0)
 ; Now process each routine that has been referenced
"RTN","XTMUNIT",43,0)
 S XTMUNIT("CURR")=0
"RTN","XTMUNIT",44,0)
 F  S XTMUNIT("CURR")=XTMUNIT("CURR")+1 Q:'$D(XTMUROU(XTMUNIT("CURR")))  D
"RTN","XTMUNIT",45,0)
 . ; build a list of entry points for this routine
"RTN","XTMUNIT",46,0)
 . N XTMUETRY S XTMUNIT("ENTN")=0
"RTN","XTMUNIT",47,0)
 . F XTMUI=1:1 S XTMUNIT("ELIN")=$T(@("XTENT+"_XTMUI_"^"_XTMUROU(XTMUNIT("CURR")))) Q:$P(XTMUNIT("ELIN"),";",3)=""  D
"RTN","XTMUNIT",48,0)
 . . S XTMUNIT("ENTN")=XTMUNIT("ENTN")+1,XTMUETRY(XTMUNIT("ENTN"))=$P(XTMUNIT("ELIN"),";",3),XTMUETRY(XTMUNIT("ENTN"),"NAME")=$P(XTMUNIT("ELIN"),";",4)
"RTN","XTMUNIT",49,0)
 . . Q
"RTN","XTMUNIT",50,0)
 . ; if a SETUP entry point exists, do it first
"RTN","XTMUNIT",51,0)
 . S XTMUNIT("LINE")=$T(@("SETUP^"_XTMUROU(XTMUNIT("CURR")))) I XTMUNIT("LINE")'="" D
"RTN","XTMUNIT",52,0)
 . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT",XTMUNIT("ENT")="SETUP^"_XTMUROU(XTMUNIT("CURR")),XTMUNIT("NAME")="Setup code"
"RTN","XTMUNIT",53,0)
 . . D @("SETUP^"_XTMUROU(XTMUNIT("CURR")))
"RTN","XTMUNIT",54,0)
 . . Q
"RTN","XTMUNIT",55,0)
 . ; run each of the specified entry points
"RTN","XTMUNIT",56,0)
 . S XTMUI=0 F  S XTMUI=$O(XTMUETRY(XTMUI)) Q:XTMUI'>0  S XTMUNIT("ENUM")=XTMUNIT("ERRN")+XTMUNIT("FAIL") D  I XTMUVERB,'$D(XTMUGUI),XTMUNIT("ENUM")=(XTMUNIT("ERRN")+XTMUNIT("FAIL")) D VERBOSE(.XTMUETRY,XTMUI)
"RTN","XTMUNIT",57,0)
 . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
"RTN","XTMUNIT",58,0)
 . . S XTMUNIT("ECNT")=XTMUNIT("ECNT")+1,XTMUNIT("NAME")=XTMUETRY(XTMUI,"NAME"),XTMUNIT("ENT")=XTMUETRY(XTMUI)_"^"_XTMUROU(XTMUNIT("CURR")) D @XTMUNIT("ENT")
"RTN","XTMUNIT",59,0)
 . . Q
"RTN","XTMUNIT",60,0)
 . ; if a TEARDOWN entry point exists, do it before leaving routine
"RTN","XTMUNIT",61,0)
 . S XTMUNIT("LINE")=$T(@("TEARDOWN^"_XTMUROU(XTMUNIT("CURR")))) I XTMUNIT("LINE")'="" D
"RTN","XTMUNIT",62,0)
 . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT",XTMUNIT("ENT")="TEARDOWN^"_XTMUROU(XTMUNIT("CURR")),XTMUNIT("NAME")="Teardown code"
"RTN","XTMUNIT",63,0)
 . . D @("TEARDOWN^"_XTMUROU(XTMUNIT("CURR")))
"RTN","XTMUNIT",64,0)
 . . Q
"RTN","XTMUNIT",65,0)
 . ; keep a XTMUCNT of number of entry points executed across all routines
"RTN","XTMUNIT",66,0)
 . S XTMUNIT("NENT")=XTMUNIT("NENT")+XTMUNIT("ENTN")
"RTN","XTMUNIT",67,0)
 . Q
"RTN","XTMUNIT",68,0)
 ; 070224 - following code added to allow one overall SHUTDOWN code JLI
"RTN","XTMUNIT",69,0)
 N XTFINISH
"RTN","XTMUNIT",70,0)
 S XTMUNIT("CURR")=0
"RTN","XTMUNIT",71,0)
 F  S XTMUNIT("CURR")=XTMUNIT("CURR")+1 Q:'$D(XTMUROU(XTMUNIT("CURR")))  D  I $G(XTFINISH)'="" D @XTFINISH Q
"RTN","XTMUNIT",72,0)
 . I $T(@("SHUTDOWN^"_XTMUROU(XTMUNIT("CURR"))))'="" S XTFINISH="SHUTDOWN^"_XTMUROU(XTMUNIT("CURR"))
"RTN","XTMUNIT",73,0)
 . Q
"RTN","XTMUNIT",74,0)
 ; 070224 - End of addition JLI
"RTN","XTMUNIT",75,0)
 S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
"RTN","XTMUNIT",76,0)
 I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
"RTN","XTMUNIT",77,0)
 W !!,"Ran ",XTMULIST," Routine",$S(XTMULIST>1:"s",1:""),", ",XTMUNIT("NENT")," Entry Tag",$S(XTMUNIT("NENT")>1:"s",1:"")
"RTN","XTMUNIT",78,0)
 W !,"Checked ",XTMUNIT("CHK")," test",$S(XTMUNIT("CHK")>1:"s",1:""),", with ",XTMUNIT("FAIL")," failure",$S(XTMUNIT("FAIL")'=1:"s",1:"")," and encountered ",XTMUNIT("ERRN")," error",$S(XTMUNIT("ERRN")'=1:"s",1:""),"."
"RTN","XTMUNIT",79,0)
 I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
"RTN","XTMUNIT",80,0)
 Q
"RTN","XTMUNIT",81,0)
 ; -- end EN1
"RTN","XTMUNIT",82,0)
VERBOSE(XTMUETRY,XTMUI) ;
"RTN","XTMUNIT",83,0)
 N OLDIO,OLDIOFLG,OLDIONAM
"RTN","XTMUNIT",84,0)
 ; ZEXCEPT: XTMUNIT - NEWED IN EN
"RTN","XTMUNIT",85,0)
 S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
"RTN","XTMUNIT",86,0)
 I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
"RTN","XTMUNIT",87,0)
 W !,"OK - ",XTMUETRY(XTMUI) I $G(XTMUETRY(XTMUI,"NAME"))'="" W " - ",XTMUETRY(XTMUI,"NAME")
"RTN","XTMUNIT",88,0)
 IF OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
"RTN","XTMUNIT",89,0)
 Q
"RTN","XTMUNIT",90,0)
 ;
"RTN","XTMUNIT",91,0)
GETTREE(XTMUROU,XTMULIST) ;
"RTN","XTMUNIT",92,0)
 ; first get any other routines this one references for running subsequently
"RTN","XTMUNIT",93,0)
 ; then any that they refer to as well
"RTN","XTMUNIT",94,0)
 ; this builds a tree of all routines referred to by any routine including each only once
"RTN","XTMUNIT",95,0)
 N XTMUK,XTMUI,XTMUJ,XTMURNAM,XTMURLIN
"RTN","XTMUNIT",96,0)
 F XTMUK=1:1 Q:'$D(XTMUROU(XTMUK))  D
"RTN","XTMUNIT",97,0)
 . F XTMUI=1:1 S XTMURLIN=$T(@("XTROU+"_XTMUI_"^"_XTMUROU(XTMUK))) S XTMURNAM=$P(XTMURLIN,";",3) Q:XTMURNAM=""  D
"RTN","XTMUNIT",98,0)
 . . F XTMUJ=1:1:XTMULIST I XTMUROU(XTMUJ)=XTMURNAM S XTMURNAM="" Q
"RTN","XTMUNIT",99,0)
 . . I XTMURNAM'="",$T(@("+1^"_XTMURNAM))="" W:'$D(XWBOS) "Referenced routine ",XTMURNAM," not found.",! Q
"RTN","XTMUNIT",100,0)
 . . S:XTMURNAM'="" XTMULIST=XTMULIST+1,XTMUROU(XTMULIST)=XTMURNAM
"RTN","XTMUNIT",101,0)
 . . Q
"RTN","XTMUNIT",102,0)
 . Q
"RTN","XTMUNIT",103,0)
 Q
"RTN","XTMUNIT",104,0)
 ;
"RTN","XTMUNIT",105,0)
CHKTF(XTSTVAL,XTERMSG) ; Entry point for checking True or False values
"RTN","XTMUNIT",106,0)
 N OLDIO,OLDIOFLG,OLDIONAM
"RTN","XTMUNIT",107,0)
 ; ZEXCEPT: XTMUERRL,XTMUGUI - CREATED IN SETUP, KILLED IN END
"RTN","XTMUNIT",108,0)
 ; ZEXCEPT: XTMUNIT - NEWED IN EN
"RTN","XTMUNIT",109,0)
 I $G(XTSTVAL)="" D NVLDARG Q
"RTN","XTMUNIT",110,0)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
"RTN","XTMUNIT",111,0)
 S XTMUNIT("CHK")=$G(XTMUNIT("CHK"))+1
"RTN","XTMUNIT",112,0)
 I '$D(XTMUGUI) D
"RTN","XTMUNIT",113,0)
 . S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
"RTN","XTMUNIT",114,0)
 . I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
"RTN","XTMUNIT",115,0)
 . I 'XTSTVAL W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - " D
"RTN","XTMUNIT",116,0)
 . . W XTERMSG,! S XTMUNIT("FAIL")=XTMUNIT("FAIL")+1,XTMUERRL(XTMUNIT("FAIL"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=XTERMSG,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
"RTN","XTMUNIT",117,0)
 . . Q
"RTN","XTMUNIT",118,0)
 . E  W "."
"RTN","XTMUNIT",119,0)
 . I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
"RTN","XTMUNIT",120,0)
 . Q
"RTN","XTMUNIT",121,0)
 I $D(XTMUGUI),'XTSTVAL S XTMUNIT("CNT")=XTMUNIT("CNT")+1,@XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG
"RTN","XTMUNIT",122,0)
 Q
"RTN","XTMUNIT",123,0)
 ;
"RTN","XTMUNIT",124,0)
CHKEQ(XTEXPECT,XTACTUAL,XTERMSG) ; Entry point for checking values to see if they are EQUAL
"RTN","XTMUNIT",125,0)
 N FAILMSG,OLDIO,OLDIOFLG,OLDIONAM
"RTN","XTMUNIT",126,0)
 ; ZEXCEPT: XTMUERRL,XTMUGUI -CREATED IN SETUP, KILLED IN END
"RTN","XTMUNIT",127,0)
 ; ZEXCEPT: XTMUNIT  -- NEWED IN EN
"RTN","XTMUNIT",128,0)
 I '$D(XTEXPECT),'$D(XTACTUAL) D NVLDARG Q
"RTN","XTMUNIT",129,0)
 S XTACTUAL=$G(XTACTUAL),XTEXPECT=$G(XTEXPECT)
"RTN","XTMUNIT",130,0)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
"RTN","XTMUNIT",131,0)
 S XTMUNIT("CHK")=XTMUNIT("CHK")+1
"RTN","XTMUNIT",132,0)
 I XTEXPECT'=XTACTUAL S FAILMSG="<"_XTEXPECT_"> vs <"_XTACTUAL_"> - "
"RTN","XTMUNIT",133,0)
 I '$D(XTMUGUI) D
"RTN","XTMUNIT",134,0)
 . S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
"RTN","XTMUNIT",135,0)
 . I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
"RTN","XTMUNIT",136,0)
 . I XTEXPECT'=XTACTUAL W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - " W FAILMSG,XTERMSG,! D
"RTN","XTMUNIT",137,0)
 . . S XTMUNIT("FAIL")=XTMUNIT("FAIL")+1,XTMUERRL(XTMUNIT("FAIL"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=XTERMSG,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
"RTN","XTMUNIT",138,0)
 . . Q
"RTN","XTMUNIT",139,0)
 . E  W "."
"RTN","XTMUNIT",140,0)
 . I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
"RTN","XTMUNIT",141,0)
 . Q
"RTN","XTMUNIT",142,0)
 I $D(XTMUGUI),XTEXPECT'=XTACTUAL S XTMUNIT("CNT")=XTMUNIT("CNT")+1,@XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_FAILMSG_XTERMSG
"RTN","XTMUNIT",143,0)
 Q
"RTN","XTMUNIT",144,0)
 ;
"RTN","XTMUNIT",145,0)
FAIL(XTERMSG) ; Entry point for generating a failure message
"RTN","XTMUNIT",146,0)
 N OLDIO,OLDIOFLG,OLDIONAM
"RTN","XTMUNIT",147,0)
 ; ZEXCEPT: XTMUERRL,XTMUGUI -CREATED IN SETUP, KILLED IN END
"RTN","XTMUNIT",148,0)
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
"RTN","XTMUNIT",149,0)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
"RTN","XTMUNIT",150,0)
 S XTMUNIT("CHK")=XTMUNIT("CHK")+1
"RTN","XTMUNIT",151,0)
 I '$D(XTMUGUI) D
"RTN","XTMUNIT",152,0)
 . S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
"RTN","XTMUNIT",153,0)
 . I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
"RTN","XTMUNIT",154,0)
 . W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - " W XTERMSG,! D
"RTN","XTMUNIT",155,0)
 . . S XTMUNIT("FAIL")=XTMUNIT("FAIL")+1,XTMUERRL(XTMUNIT("FAIL"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=XTERMSG,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
"RTN","XTMUNIT",156,0)
 . . Q
"RTN","XTMUNIT",157,0)
 . I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
"RTN","XTMUNIT",158,0)
 . Q
"RTN","XTMUNIT",159,0)
 I $D(XTMUGUI) S XTMUNIT("CNT")=XTMUNIT("CNT")+1,@XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG
"RTN","XTMUNIT",160,0)
 Q
"RTN","XTMUNIT",161,0)
 ;
"RTN","XTMUNIT",162,0)
CHKLEAKS(XTMUCODE,XTMULOC,XTMUINPT) ; functionality to check for variable leaks on executing a section of code
"RTN","XTMUNIT",163,0)
 ; XTMUCODE - A string that specifies the code that is to be XECUTED and checked for leaks.
"RTN","XTMUNIT",164,0)
 ;            this should be a complete piece of code (e.g., "S X=$$NEW^XLFDT()" or "D EN^XTMUNIT(""ROUNAME"")")
"RTN","XTMUNIT",165,0)
 ; XTMULOC  - A string that is used to indicate the code tested for variable leaks
"RTN","XTMUNIT",166,0)
 ; XTMUINPT - An optional variable which may be passed by reference.  This may
"RTN","XTMUNIT",167,0)
 ;           be used to pass any variable values, etc. into the code to be
"RTN","XTMUNIT",168,0)
 ;           XECUTED.  In this case, set the subscript to the variable name and the
"RTN","XTMUNIT",169,0)
 ;           value of the subscripted variable to the desired value of the subscript.
"RTN","XTMUNIT",170,0)
 ;              e.g., (using NAME as my current namespace)
"RTN","XTMUNIT",171,0)
 ;                   S CODE="S XTMUINPT=$$ENTRY^ROUTINE(ZZVALUE1,ZZVALUE2)"
"RTN","XTMUNIT",172,0)
 ;                   S NAMELOC="ENTRY^ROUTINE leak test"   (or simply "ENTRY^ROUTINE")
"RTN","XTMUNIT",173,0)
 ;                   S NAMEINPT("ZZVALUE1")=ZZVALUE1
"RTN","XTMUNIT",174,0)
 ;                   S NAMEINPT("ZZVALUE2")=ZZVALUE2
"RTN","XTMUNIT",175,0)
 ;                   D CHKLEAKS^XTMUNIT(CODE,NAMELOC,.NAMEINPT)
"RTN","XTMUNIT",176,0)
 ;
"RTN","XTMUNIT",177,0)
 ;           If part of a unit test, any leaked variables in ENTRY^ROUTINE which result
"RTN","XTMUNIT",178,0)
 ;           from running the code with the variables indicated will be shown as FAILUREs.
"RTN","XTMUNIT",179,0)
 ;
"RTN","XTMUNIT",180,0)
 ;           If called outside of a unit test, any leaked variables will be printed to the
"RTN","XTMUNIT",181,0)
 ;           current device.
"RTN","XTMUNIT",182,0)
 ;
"RTN","XTMUNIT",183,0)
 N (XTMUCODE,XTMULOC,XTMUINPT,DUZ,IO,U,XTMUERRL,XTMUNIT,XTMUGUI,XTMUI,XTMUJ,XTMUK,XTMULIST,XTMUROU,XTMUSTRT)
"RTN","XTMUNIT",184,0)
 ; ZEXCEPT: XTMUNIT - part of exclusive NEW TESTS FOR EXISTENCE ONLY
"RTN","XTMUNIT",185,0)
 ; ZEXCEPT: XTMUVAR - handled by exclusive NEW
"RTN","XTMUNIT",186,0)
 ;
"RTN","XTMUNIT",187,0)
 ; ACTIVATE ANY VARIABLES PASSED AS SUBSCRIPTS TO XTMUINPT TO THEIR VALUES
"RTN","XTMUNIT",188,0)
 S XTMUVAR=" " F  S XTMUVAR=$O(XTMUINPT(XTMUVAR)) Q:XTMUVAR=""  S (@XTMUVAR)=XTMUINPT(XTMUVAR)
"RTN","XTMUNIT",189,0)
 X XTMUCODE
"RTN","XTMUNIT",190,0)
 N ZZUTVAR S ZZUTVAR="%"
"RTN","XTMUNIT",191,0)
 I $G(XTMUNIT)=1 D
"RTN","XTMUNIT",192,0)
 . I $D(@ZZUTVAR),'$D(XTMUINPT(ZZUTVAR)) D FAIL^XTMUNIT(XTMULOC_" VARIABLE LEAK: "_ZZUTVAR)
"RTN","XTMUNIT",193,0)
 . F  S ZZUTVAR=$O(@ZZUTVAR) Q:ZZUTVAR=""  I $E(ZZUTVAR,1,4)'="XTMU",'$D(XTMUINPT(ZZUTVAR)),",DUZ,IO,U,DTIME,ZZUTVAR,DT,"'[(","_ZZUTVAR_",") D FAIL^XTMUNIT(XTMULOC_" VARIABLE LEAK: "_ZZUTVAR)
"RTN","XTMUNIT",194,0)
 . Q
"RTN","XTMUNIT",195,0)
 I '($G(XTMUNIT)=1) D
"RTN","XTMUNIT",196,0)
 . I $D(@ZZUTVAR),'$D(XTMUINPT(ZZUTVAR)) W !,XTMULOC_" VARIABLE LEAK: "_ZZUTVAR
"RTN","XTMUNIT",197,0)
 . F  S ZZUTVAR=$O(@ZZUTVAR) Q:ZZUTVAR=""  I $E(ZZUTVAR,1,4)'="XTMU",'$D(XTMUINPT(ZZUTVAR)),",DUZ,IO,U,DTIME,ZZUTVAR,DT,"'[(","_ZZUTVAR_",") W !,XTMULOC_" VARIABLE LEAK: "_ZZUTVAR
"RTN","XTMUNIT",198,0)
 . Q
"RTN","XTMUNIT",199,0)
 Q
"RTN","XTMUNIT",200,0)
 ;
"RTN","XTMUNIT",201,0)
NVLDARG ; generate message for invalid arguments to test
"RTN","XTMUNIT",202,0)
 N XTERMSG,OLDIO,OLDIOFLG,OLDIONAM
"RTN","XTMUNIT",203,0)
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
"RTN","XTMUNIT",204,0)
 ; ZEXCEPT: XTMUERRL,XTMUGUI -CREATED IN SETUP, KILLED IN END
"RTN","XTMUNIT",205,0)
 S XTERMSG="NO VALUES INPUT TO CHKEQ^XTMUNIT - no evaluation possible"
"RTN","XTMUNIT",206,0)
 I '$D(XTMUGUI) D
"RTN","XTMUNIT",207,0)
 . S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
"RTN","XTMUNIT",208,0)
 . I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
"RTN","XTMUNIT",209,0)
 . W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - " W XTERMSG,! D
"RTN","XTMUNIT",210,0)
 . . S XTMUNIT("FAIL")=XTMUNIT("FAIL")+1,XTMUERRL(XTMUNIT("FAIL"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=XTERMSG,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
"RTN","XTMUNIT",211,0)
 . . Q
"RTN","XTMUNIT",212,0)
 . I OLDIO'=IO D RESETIO(OLDIOFLG,OLDIONAM)
"RTN","XTMUNIT",213,0)
 . Q
"RTN","XTMUNIT",214,0)
 I $D(XTMUGUI) S XTMUNIT("CNT")=XTMUNIT("CNT")+1,@XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG
"RTN","XTMUNIT",215,0)
 Q
"RTN","XTMUNIT",216,0)
 ;
"RTN","XTMUNIT",217,0)
ERROR ; record errors
"RTN","XTMUNIT",218,0)
 ; ZEXCEPT: XTMUERRL,XTMUGUI,XTMUERR -CREATED IN SETUP, KILLED IN END
"RTN","XTMUNIT",219,0)
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
"RTN","XTMUNIT",220,0)
 S XTMUNIT("CHK")=XTMUNIT("CHK")+1
"RTN","XTMUNIT",221,0)
 I '$D(XTMUGUI) D ERROR1
"RTN","XTMUNIT",222,0)
 I $D(XTMUGUI) D
"RTN","XTMUNIT",223,0)
 . S XTMUNIT("CNT")=XTMUNIT("CNT")+1
"RTN","XTMUNIT",224,0)
 . S XTMUERR=XTMUERR+1
"RTN","XTMUNIT",225,0)
 . S @XTMUNIT("RSLT")@(XTMUNIT("CNT"))=XTMUNIT("LOC")_XTGUISEP_"ERROR"_XTGUISEP_$ZE
"RTN","XTMUNIT",226,0)
 . Q
"RTN","XTMUNIT",227,0)
 S $ZE="",$EC=""
"RTN","XTMUNIT",228,0)
 Q
"RTN","XTMUNIT",229,0)
 ;
"RTN","XTMUNIT",230,0)
ERROR1 ;
"RTN","XTMUNIT",231,0)
 N OLDIO,OLDIOFLG,OLDIONAM
"RTN","XTMUNIT",232,0)
 ; ZEXCEPT: XTMUERRL -CREATED IN SETUP, KILLED IN END
"RTN","XTMUNIT",233,0)
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
"RTN","XTMUNIT",234,0)
 S OLDIO=IO,OLDIOFLG=0,OLDIONAM=""
"RTN","XTMUNIT",235,0)
 I IO'=XTMUNIT("IO") D SETIO(.OLDIOFLG,.OLDIONAM)
"RTN","XTMUNIT",236,0)
 W !,XTMUNIT("ENT")," - " W:XTMUNIT("NAME")'="" XTMUNIT("NAME")," - Error: " W $ZE,! D
"RTN","XTMUNIT",237,0)
 . S XTMUNIT("ERRN")=XTMUNIT("ERRN")+1,XTMUERRL(XTMUNIT("ERRN"))=XTMUNIT("NAME"),XTMUERRL(XTMUNIT("FAIL"),"MSG")=$ZE,XTMUERRL(XTMUNIT("FAIL"),"ENTRY")=XTMUNIT("ENT")
"RTN","XTMUNIT",238,0)
 . Q
"RTN","XTMUNIT",239,0)
 I IO'=OLDIO D RESETIO(OLDIOFLG,OLDIONAM)
"RTN","XTMUNIT",240,0)
 Q
"RTN","XTMUNIT",241,0)
SETIO(OLDIOFLG,OLDIONAM) ; BOTH PASSED BY REFERENCE
"RTN","XTMUNIT",242,0)
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
"RTN","XTMUNIT",243,0)
 N OLDION S OLDION="" F  S OLDION=$O(^TMP("XUDEVICE",$J,OLDION)) Q:OLDION=""  I $G(^(OLDION,"IO"))=IO S OLDIONAM=^(0),OLDIOFLG=1
"RTN","XTMUNIT",244,0)
 I 'OLDIOFLG S OLDIONAM="OLD MUNIT DEV" D SAVDEV^%ZISUTL(OLDIONAM)
"RTN","XTMUNIT",245,0)
 D USE^%ZISUTL(XTMUNIT("DEV"))
"RTN","XTMUNIT",246,0)
 Q
"RTN","XTMUNIT",247,0)
 ;
"RTN","XTMUNIT",248,0)
RESETIO(OLDIOFLG,OLDIONAM) ;
"RTN","XTMUNIT",249,0)
 D USE^%ZISUTL(OLDIONAM) I 'OLDIOFLG D RMDEV^%ZISUTL(OLDIONAM)
"RTN","XTMUNIT",250,0)
 Q
"RTN","XTMUNIT",251,0)
 ;
"RTN","XTMUNIT",252,0)
ISUTEST() ; .SUPPORTED API TO DETERMINE IF CURRENTLY IN UNIT TEST
"RTN","XTMUNIT",253,0)
 ; ZEXCEPT: XTMUNIT  -- NEWED ON ENTRY
"RTN","XTMUNIT",254,0)
 Q $G(XTMUNIT)=1
"RTN","XTMUNIT",255,0)
 ;
"RTN","XTMUNIT",256,0)
PICKSET ; .OPT Interactive selection of MUnit Test Group
"RTN","XTMUNIT",257,0)
 N DIC,Y,XTMUROU,XTMULIST,DIR
"RTN","XTMUNIT",258,0)
 S DIC=8992.8,DIC(0)="AEQM" D ^DIC Q:Y'>0  W !
"RTN","XTMUNIT",259,0)
 D GETSET(+Y,.XTMUROU,.XTMULIST)
"RTN","XTMUNIT",260,0)
 N DIC,Y,XTMUNIT
"RTN","XTMUNIT",261,0)
 D SETUT
"RTN","XTMUNIT",262,0)
 D EN1(.XTMUROU,XTMULIST)
"RTN","XTMUNIT",263,0)
 S DIR(0)="EA",DIR("A")="Enter RETURN to continue:" D ^DIR K DIR
"RTN","XTMUNIT",264,0)
 Q
"RTN","XTMUNIT",265,0)
 ;
"RTN","XTMUNIT",266,0)
RUNSET(SETNAME) ; .SR Run with Specified Selection of MUnit Test Group
"RTN","XTMUNIT",267,0)
 N Y,XTMUROU,XTMULIST
"RTN","XTMUNIT",268,0)
 Q:$G(SETNAME)=""
"RTN","XTMUNIT",269,0)
 S Y=+$$FIND1^DIC(8992.8,"","X",SETNAME) Q:Y'>0
"RTN","XTMUNIT",270,0)
 D GETSET(Y,.XTMUROU,.XTMULIST)
"RTN","XTMUNIT",271,0)
 N Y,SETNAME,XTMUNIT
"RTN","XTMUNIT",272,0)
 D SETUT
"RTN","XTMUNIT",273,0)
 D EN1(.XTMUROU,XTMULIST)
"RTN","XTMUNIT",274,0)
 Q
"RTN","XTMUNIT",275,0)
 ;
"RTN","XTMUNIT",276,0)
DOSET(IEN) ;
"RTN","XTMUNIT",277,0)
 N XTMUROU,XTMULIST
"RTN","XTMUNIT",278,0)
 S XTMULIST=0
"RTN","XTMUNIT",279,0)
 D GETSET($G(IEN),.XTMUROU,.XTMULIST)
"RTN","XTMUNIT",280,0)
 I XTMULIST>0  N IEN,XTMUNIT D SETUT,EN1(.XTMUROU,XTMULIST)
"RTN","XTMUNIT",281,0)
 Q
"RTN","XTMUNIT",282,0)
 ;
"RTN","XTMUNIT",283,0)
GETSET(IEN,XTMUROU,XTMULIST) ;
"RTN","XTMUNIT",284,0)
 N IENS,XTMROOT
"RTN","XTMUNIT",285,0)
 S IENS=IEN_"," D GETS^DIQ(8992.8,IENS,"1*","","XTMROOT")
"RTN","XTMUNIT",286,0)
 S XTMULIST=0,IENS="" F  S IENS=$O(XTMROOT(8992.81,IENS)) Q:IENS=""  S XTMULIST=XTMULIST+1,XTMUROU(XTMULIST)=XTMROOT(8992.81,IENS,.01)
"RTN","XTMUNIT",287,0)
 Q
"RTN","XTMUNIT",288,0)
 ;
"RTN","XTMUNIT",289,0)
GUISET(XTMURSLT,XTSET) ; Entry point for GUI start with selected Test Set IEN
"RTN","XTMUNIT",290,0)
 N XTMUROU,XTMULIST,XTMUNIT
"RTN","XTMUNIT",291,0)
 D SETUT
"RTN","XTMUNIT",292,0)
 S XTMUNIT("RSLT")=$NA(^TMP("MUNIT-XTMURSLT",$J)) K @XTMUNIT("RSLT")
"RTN","XTMUNIT",293,0)
 D GETSET(XTSET,.XTMUROU,.XTMULIST)
"RTN","XTMUNIT",294,0)
 D GETLIST(.XTMUROU,XTMULIST,XTMUNIT("RSLT"))
"RTN","XTMUNIT",295,0)
 S @XTMUNIT("RSLT")@(1)=(@XTMUNIT("RSLT")@(1))_"^1" ; 110719 mark as new version
"RTN","XTMUNIT",296,0)
 S XTMURSLT=XTMUNIT("RSLT")
"RTN","XTMUNIT",297,0)
 Q
"RTN","XTMUNIT",298,0)
 ;
"RTN","XTMUNIT",299,0)
GUILOAD(XTMURSLT,XTMUROUN) ; Entry point for GUI start with XTMUROUN containing primary routine name
"RTN","XTMUNIT",300,0)
 N XTMUROU,XTMUNIT
"RTN","XTMUNIT",301,0)
 D SETUT
"RTN","XTMUNIT",302,0)
 S XTMUNIT("RSLT")=$NA(^TMP("MUNIT-XTMURSLT",$J)) K @XTMUNIT("RSLT")
"RTN","XTMUNIT",303,0)
 S XTMUROU(1)=XTMUROUN
"RTN","XTMUNIT",304,0)
 D GETLIST(.XTMUROU,1,XTMUNIT("RSLT"))
"RTN","XTMUNIT",305,0)
 S @XTMUNIT("RSLT")@(1)=(@XTMUNIT("RSLT")@(1))_"^1" ; 110719 mark as new version
"RTN","XTMUNIT",306,0)
 S XTMURSLT=XTMUNIT("RSLT")
"RTN","XTMUNIT",307,0)
 Q
"RTN","XTMUNIT",308,0)
 ;
"RTN","XTMUNIT",309,0)
GETLIST(XTMUROU,XTMULIST,XTMURSLT) ;
"RTN","XTMUNIT",310,0)
 N I,XTMUROUL,XTMUROUN,XTMUNIT,XTCOMNT,XTVALUE,XTMUCNT
"RTN","XTMUNIT",311,0)
 S XTVALUE=$NA(^TMP("GUI-MUNIT",$J)) K @XTVALUE
"RTN","XTMUNIT",312,0)
 S XTMUCNT=0,XTCOMNT=""
"RTN","XTMUNIT",313,0)
 D GETTREE(.XTMUROU,XTMULIST)
"RTN","XTMUNIT",314,0)
 F I=1:1 Q:'$D(XTMUROU(I))  S XTMUROUL(XTMUROU(I))=""
"RTN","XTMUNIT",315,0)
 S XTMUROUN="" F  S XTMUROUN=$O(XTMUROUL(XTMUROUN)) Q:XTMUROUN=""  D LOAD(XTMUROUN,.XTMUCNT,XTVALUE,XTCOMNT,.XTMUROUL)
"RTN","XTMUNIT",316,0)
 M @XTMURSLT=@XTVALUE
"RTN","XTMUNIT",317,0)
 K @XTMURSLT@("SHUTDOWN")
"RTN","XTMUNIT",318,0)
 K @XTMURSLT@("STARTUP")
"RTN","XTMUNIT",319,0)
 S @XTVALUE@("LASTROU")="" ; Use this to keep track of place in routines
"RTN","XTMUNIT",320,0)
 Q
"RTN","XTMUNIT",321,0)
 ;
"RTN","XTMUNIT",322,0)
 ; generate list of unit test routines, entry points and comments on test for entry point
"RTN","XTMUNIT",323,0)
LOAD(XTMUROUN,XTMUNCNT,XTVALUE,XTCOMNT,XTMUROUL) ;
"RTN","XTMUNIT",324,0)
 I $T(@("^"_XTMUROUN))="" S XTMUNCNT=XTMUNCNT+1,@XTVALUE@(XTMUNCNT)=XTMUROUN_"^^*** ERROR - ROUTINE NAME NOT FOUND" Q
"RTN","XTMUNIT",325,0)
 S XTMUNCNT=XTMUNCNT+1,@XTVALUE@(XTMUNCNT)=XTMUROUN_U_U_XTCOMNT
"RTN","XTMUNIT",326,0)
 N XTMUI,XTX1,XTX2,LINE
"RTN","XTMUNIT",327,0)
 ; 100622 JLI added code to identify STARTUP and TEARDOWN
"RTN","XTMUNIT",328,0)
 I $T(@("STARTUP^"_XTMUROUN))'="",'$D(@XTVALUE@("STARTUP")) S @XTVALUE@("STARTUP")="STARTUP^"_XTMUROUN
"RTN","XTMUNIT",329,0)
 I $T(@("SHUTDOWN^"_XTMUROUN))'="",'$D(@XTVALUE@("SHUTDOWN")) S @XTVALUE@("SHUTDOWN")="SHUTDOWN^"_XTMUROUN
"RTN","XTMUNIT",330,0)
 F XTMUI=1:1 S LINE=$T(@("XTENT+"_XTMUI_"^"_XTMUROUN)) S XTX1=$P(LINE,";",3) Q:XTX1=""  S XTX2=$P(LINE,";",4),XTMUNCNT=XTMUNCNT+1,@XTVALUE@(XTMUNCNT)=XTMUROUN_U_XTX1_U_XTX2
"RTN","XTMUNIT",331,0)
 F XTMUI=1:1 S LINE=$T(@("XTROU+"_XTMUI_"^"_XTMUROUN)) S XTX1=$P(LINE,";",3) Q:XTX1=""  S XTCOMNT=$P(LINE,";",4) I '$D(XTMUROUL(XTX1)) S XTMUROUL(XTX1)="" D LOAD(XTX1,.XTMUNCNT,XTVALUE,XTCOMNT,.XTMUROUL)
"RTN","XTMUNIT",332,0)
 Q
"RTN","XTMUNIT",333,0)
 ;
"RTN","XTMUNIT",334,0)
GUINEXT(XTMURSLT,XTMULOC,XTGUISEP) ; Entry point for GUI execute next test
"RTN","XTMUNIT",335,0)
 ; XTGUISEP - added 110719 to provide for changing separator for GUI
"RTN","XTMUNIT",336,0)
 ;            return from ^ to another value ~~^~~  so that data returned
"RTN","XTMUNIT",337,0)
 ;            is not affected by ^ values in the data - if not present
"RTN","XTMUNIT",338,0)
 ;            sets value to default ^
"RTN","XTMUNIT",339,0)
 N XTMUETRY,XTMUROUT,XTOLROU,XTVALUE,XTMUERR,XTMUGUI
"RTN","XTMUNIT",340,0)
 N XTMUNIT
"RTN","XTMUNIT",341,0)
 I $G(XTGUISEP)="" S XTGUISEP="^"
"RTN","XTMUNIT",342,0)
 D SETUT
"RTN","XTMUNIT",343,0)
 S XTMUNIT("CNT")=0,XTMUNIT("LOC")=XTMULOC
"RTN","XTMUNIT",344,0)
 S XTVALUE=$NA(^TMP("GUI-MUNIT",$J))
"RTN","XTMUNIT",345,0)
 S XTMUNIT("RSLT")=$NA(^TMP("GUINEXT",$J)) K @XTMUNIT("RSLT")
"RTN","XTMUNIT",346,0)
 S XTMURSLT=XTMUNIT("RSLT")
"RTN","XTMUNIT",347,0)
 S XTMUETRY=$P(XTMULOC,U),XTMUROUT=$P(XTMULOC,U,2),XTOLROU=$G(@XTVALUE@("LASTROU"))
"RTN","XTMUNIT",348,0)
 S XTMUGUI=1
"RTN","XTMUNIT",349,0)
 I XTMUROUT'=XTOLROU D  I XTMUROUT="" S @XTMURSLT@(1)="" K @XTVALUE Q
"RTN","XTMUNIT",350,0)
 . ; 100622 JLI added code to handle STARTUP for GUI app
"RTN","XTMUNIT",351,0)
 . I XTOLROU="",$D(@XTVALUE@("STARTUP")) D
"RTN","XTMUNIT",352,0)
 . . S XTMUNIT("LOC")=@XTVALUE@("STARTUP")
"RTN","XTMUNIT",353,0)
 . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
"RTN","XTMUNIT",354,0)
 . . D @(@XTVALUE@("STARTUP"))
"RTN","XTMUNIT",355,0)
 . . Q
"RTN","XTMUNIT",356,0)
 . I XTOLROU'="" I $T(@("TEARDOWN^"_XTOLROU))'="" D
"RTN","XTMUNIT",357,0)
 . . S XTMUNIT("LOC")="TEARDOWN^"_XTMUROUT
"RTN","XTMUNIT",358,0)
 . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
"RTN","XTMUNIT",359,0)
 . . D @("TEARDOWN^"_XTOLROU)
"RTN","XTMUNIT",360,0)
 . . Q
"RTN","XTMUNIT",361,0)
 . S @XTVALUE@("LASTROU")=XTMUROUT I XTMUROUT'="",$T(@("SETUP^"_XTMUROUT))'="" D
"RTN","XTMUNIT",362,0)
 . . S XTMUNIT("LOC")="SETUP^"_XTMUROUT
"RTN","XTMUNIT",363,0)
 . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
"RTN","XTMUNIT",364,0)
 . . D @("SETUP^"_XTMUROUT)
"RTN","XTMUNIT",365,0)
 . . Q
"RTN","XTMUNIT",366,0)
 . ; 100622 JLI added code to handle SHUTDOWN
"RTN","XTMUNIT",367,0)
 . I XTMUROUT="",$D(@XTVALUE@("SHUTDOWN")) D
"RTN","XTMUNIT",368,0)
 . . S XTMUNIT("LOC")=@XTVALUE@("SHUTDOWN")
"RTN","XTMUNIT",369,0)
 . . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
"RTN","XTMUNIT",370,0)
 . . D @(@XTVALUE@("SHUTDOWN"))
"RTN","XTMUNIT",371,0)
 . . Q
"RTN","XTMUNIT",372,0)
 . Q
"RTN","XTMUNIT",373,0)
 S XTMUNIT("LOC")=XTMULOC
"RTN","XTMUNIT",374,0)
 S XTMUNIT("CHK")=0,XTMUNIT("CNT")=1,XTMUERR=0
"RTN","XTMUNIT",375,0)
 D  ; to limit range of error trap so we continue through other tests
"RTN","XTMUNIT",376,0)
 . N $ETRAP S $ETRAP="D ERROR^XTMUNIT"
"RTN","XTMUNIT",377,0)
 . D @XTMUNIT("LOC")
"RTN","XTMUNIT",378,0)
 S @XTMUNIT("RSLT")@(1)=XTMUNIT("CHK")_XTGUISEP_(XTMUNIT("CNT")-1-XTMUERR)_XTGUISEP_XTMUERR
"RTN","XTMUNIT",379,0)
 Q
"SEC","^DIC",8992.7,8992.7,0,"AUDIT")
@
"SEC","^DIC",8992.7,8992.7,0,"DD")
@
"SEC","^DIC",8992.7,8992.7,0,"DEL")
@
"SEC","^DIC",8992.7,8992.7,0,"LAYGO")
@
"SEC","^DIC",8992.7,8992.7,0,"RD")
@
"SEC","^DIC",8992.7,8992.7,0,"WR")
@
"SEC","^DIC",8992.8,8992.8,0,"AUDIT")
@
"SEC","^DIC",8992.8,8992.8,0,"DD")
@
"SEC","^DIC",8992.8,8992.8,0,"DEL")
@
"SEC","^DIC",8992.8,8992.8,0,"LAYGO")
@
"SEC","^DIC",8992.8,8992.8,0,"RD")
@
"SEC","^DIC",8992.8,8992.8,0,"WR")
@
"VER")
8.0^22.0
"^DD",8992.7,8992.7,0)
FIELD^^2.01^10
"^DD",8992.7,8992.7,0,"DT")
3100114
"^DD",8992.7,8992.7,0,"IX","B",8992.7,.01)

"^DD",8992.7,8992.7,0,"NM","LOG4M CONFIG")

"^DD",8992.7,8992.7,.01,0)
NAME^RF^^0;1^K:$L(X)>30!($L(X)<3)!'(X'?1P.E) X
"^DD",8992.7,8992.7,.01,1,0)
^.1
"^DD",8992.7,8992.7,.01,1,1,0)
8992.7^B
"^DD",8992.7,8992.7,.01,1,1,1)
S ^XTV(8992.7,"B",$E(X,1,30),DA)=""
"^DD",8992.7,8992.7,.01,1,1,2)
K ^XTV(8992.7,"B",$E(X,1,30),DA)
"^DD",8992.7,8992.7,.01,3)
Answer must be 3-30 characters in length.
"^DD",8992.7,8992.7,.01,21,0)
^^7^7^3100114^
"^DD",8992.7,8992.7,.01,21,1,0)
This field hold the NAME used to identify a particular LOG4M CONFIG
"^DD",8992.7,8992.7,.01,21,2,0)
entry.  The file holds configuration information for a particular LOG4M 
"^DD",8992.7,8992.7,.01,21,3,0)
entry.  The NAME is used within source code to specify logging startup, 
"^DD",8992.7,8992.7,.01,21,4,0)
if the NAME exists within the LOG4M CONFIG file or if the ACTIVE field is 
"^DD",8992.7,8992.7,.01,21,5,0)
set to a YES value (there are two choices for YES).  If the file entry 
"^DD",8992.7,8992.7,.01,21,6,0)
for a specific NAME does not exist, or if the ACTIVE field is set to NO, 
"^DD",8992.7,8992.7,.01,21,7,0)
then no logging will be performed.
"^DD",8992.7,8992.7,.01,23,0)
^^14^14^3100114^
"^DD",8992.7,8992.7,.01,23,1,0)
The NAME field of the LOG4M CONFIG file is used within source code to 
"^DD",8992.7,8992.7,.01,23,2,0)
identify a specific logging session and to control whether logging is 
"^DD",8992.7,8992.7,.01,23,3,0)
initiated or not.  
"^DD",8992.7,8992.7,.01,23,4,0)
 
"^DD",8992.7,8992.7,.01,23,5,0)
The easiest way to initiate logging is to use the FILEINIT entry tag in 
"^DD",8992.7,8992.7,.01,23,6,0)
the XTMLOG routine and the NAME field for an entry in the LOG4M CONFIG 
"^DD",8992.7,8992.7,.01,23,7,0)
file as an argument to specify the configuration for the logging. The
"^DD",8992.7,8992.7,.01,23,8,0)
logging is terminated with a call to the ENDLOG tag again with the NAME 
"^DD",8992.7,8992.7,.01,23,9,0)
value as an argument.
"^DD",8992.7,8992.7,.01,23,10,0)
 
"^DD",8992.7,8992.7,.01,23,11,0)
   DO FILEINIT^XTMLOG(NAME)
"^DD",8992.7,8992.7,.01,23,12,0)
   ....
"^DD",8992.7,8992.7,.01,23,13,0)
   .... 
"^DD",8992.7,8992.7,.01,23,14,0)
   DO ENDLOG^XTMLOG(NAME)
"^DD",8992.7,8992.7,.01,"DT")
3100114
"^DD",8992.7,8992.7,.02,0)
ACTIVE^RS^N:NO;E:YES, EASY CONFIG;D:YES, DETAILED CONFIG;^0;2^Q
"^DD",8992.7,8992.7,.02,3)
Enter 'N' to turn off this logging configuration.  It should be 'N' while you are editing and then turned on. Use E for EASY config specs, D for Detailed in the Word Processing field.
"^DD",8992.7,8992.7,.02,21,0)
^^12^12^3100114^
"^DD",8992.7,8992.7,.02,21,1,0)
This field determines whether, on a call to FILEINIT^XTMLOG with the NAME 
"^DD",8992.7,8992.7,.02,21,2,0)
value for a file entry, the logging is started or not.  If the value for 
"^DD",8992.7,8992.7,.02,21,3,0)
the ACTIVE field is NO, logging is not started.  If the value is YES, 
"^DD",8992.7,8992.7,.02,21,4,0)
EASY CONFIG, then logging is started using the specifications in the EZ 
"^DD",8992.7,8992.7,.02,21,5,0)
ENTRY field (#.03) and EZ LEVEL field (#.04) to determine how the logging 
"^DD",8992.7,8992.7,.02,21,6,0)
will be handled and the level of logging effort.  If the value is YES, 
"^DD",8992.7,8992.7,.02,21,7,0)
DETAILED CONFIG, then logging is started using the specifications in the 
"^DD",8992.7,8992.7,.02,21,8,0)
DETAILED CONFIG field (#1), a word processing field that would contain 
"^DD",8992.7,8992.7,.02,21,9,0)
the specifications in the manner of a Log4J configuration file.
"^DD",8992.7,8992.7,.02,21,10,0)
 
"^DD",8992.7,8992.7,.02,21,11,0)
It is recommended that the YES, EASY CONFIG be used to set the logging 
"^DD",8992.7,8992.7,.02,21,12,0)
ACTIVE.
"^DD",8992.7,8992.7,.02,"DT")
3100114
"^DD",8992.7,8992.7,.03,0)
EZ ENTRY^F^^0;3^K:$L(X)>40!($L(X)<3) X
"^DD",8992.7,8992.7,.03,3)
This can be null or an easy configuration specification [e.g., "C;G,LOGDATA", for output to console and stored under the global ^XTMP("LOGDATA",  ]
"^DD",8992.7,8992.7,.03,"DT")
3070427
"^DD",8992.7,8992.7,.04,0)
EZ LEVEL^S^FATAL:FATAL;ERROR:ERROR;WARN:WARN;INFO:INFO;DEBUG:DEBUG;^0;4^Q
"^DD",8992.7,8992.7,.04,3)
Select the level of reporting desired. A lower level (e.g., DEBUG) would include that level and all above it.
"^DD",8992.7,8992.7,.04,"DT")
3070427
"^DD",8992.7,8992.7,.05,0)
ROUTINE FILTER^F^^0;5^K:$L(X)>80!($L(X)<3) X
"^DD",8992.7,8992.7,.05,3)
Enter a list of comma separated routines, or namespaces followed by astericks which will be used for logging
"^DD",8992.7,8992.7,.05,"DT")
3080211
"^DD",8992.7,8992.7,.06,0)
USER FILTER^F^^0;6^K:$L(X)>60!($L(X)<1) X
"^DD",8992.7,8992.7,.06,3)
Enter a series of comma separated DUZ values which will be used for logging (other users will NOT be logged)
"^DD",8992.7,8992.7,.06,21,0)
^^4^4^3070518^
"^DD",8992.7,8992.7,.06,21,1,0)
This is a list of user DUZ values (comma-separated) which indicates which 
"^DD",8992.7,8992.7,.06,21,2,0)
users should have logging turned on.  This provides the capability to 
"^DD",8992.7,8992.7,.06,21,3,0)
turn on logging of a highly used piece of code for only selected users 
"^DD",8992.7,8992.7,.06,21,4,0)
instead of everyone (which is the default if this entry is a null string).
"^DD",8992.7,8992.7,.06,"DT")
3080211
"^DD",8992.7,8992.7,.07,0)
OUTPUT ON CLOSE^S^N:NONE;P:PRINTER;M:MAIL MESSAGE;^0;7^Q
"^DD",8992.7,8992.7,.07,3)
ENTER M TO SEND OUTPUT TO A MAIL MESSAGE ON ENDING LOGGING OR P TO SEND OUTPUT TO A PRINTER (MUST ENTER SPECS IN 'OUTPUT SPECS' FIELD) OR N TO DO NOTHING
"^DD",8992.7,8992.7,.07,21,0)
^^11^11^3080213^
"^DD",8992.7,8992.7,.07,21,1,0)
This field may be used to specify an output option on endding the logging
"^DD",8992.7,8992.7,.07,21,2,0)
session.  A global listing of the output must have been specified as at 
"^DD",8992.7,8992.7,.07,21,3,0)
least one output option for the data, since it will be the global data 
"^DD",8992.7,8992.7,.07,21,4,0)
used as the source of the output.  The current options are M for Mail 
"^DD",8992.7,8992.7,.07,21,5,0)
Message or P for Printer.  Selection of N or no value will result in no 
"^DD",8992.7,8992.7,.07,21,6,0)
direct output when the logging session is terminated.  If Printer output 
"^DD",8992.7,8992.7,.07,21,7,0)
is selected, the desired output device must be specified in the 'OUTPUT 
"^DD",8992.7,8992.7,.07,21,8,0)
SPECS' field.  If Mail Message output is selected, a user may be specified
"^DD",8992.7,8992.7,.07,21,9,0)
in the 'OUTPUT SPECS' field by either internal entry number or e-mail
"^DD",8992.7,8992.7,.07,21,10,0)
address, or no specification results in the mail message being sent to the
"^DD",8992.7,8992.7,.07,21,11,0)
current active user.
"^DD",8992.7,8992.7,.07,"DT")
3080213
"^DD",8992.7,8992.7,.08,0)
OUTPUT SPECS^F^^0;8^K:$L(X)>25!($L(X)<1) X
"^DD",8992.7,8992.7,.08,3)
If Printer was specified for OUTPUT ON CLOSE enter the printer specification as a value for IOP.  If Mail Message was selected, enter DUZ number(s) separated by commas, max of 25 characters.
"^DD",8992.7,8992.7,.08,21,0)
^^11^11^3080213^
"^DD",8992.7,8992.7,.08,21,1,0)
This field may be used to enter specifications related to the OUTPUT ON 
"^DD",8992.7,8992.7,.08,21,2,0)
CLOSE field.  If printer output was specified, then this field must 
"^DD",8992.7,8992.7,.08,21,3,0)
contain the specification for the desired printer in the form that would 
"^DD",8992.7,8992.7,.08,21,4,0)
be used to set the IOP value.  If mail message output was specified, this 
"^DD",8992.7,8992.7,.08,21,5,0)
may contain the DUZ values for one or more users separated by commas, or 
"^DD",8992.7,8992.7,.08,21,6,0)
it may contain e-mail addresses, separated by commas.  If nothing is 
"^DD",8992.7,8992.7,.08,21,7,0)
entered for mail message output, then the output would go to the 
"^DD",8992.7,8992.7,.08,21,8,0)
currently active user.
"^DD",8992.7,8992.7,.08,21,9,0)
 
"^DD",8992.7,8992.7,.08,21,10,0)
This field is ignored unless the OUTPUT ON CLOSE field contains either a 
"^DD",8992.7,8992.7,.08,21,11,0)
P or M.
"^DD",8992.7,8992.7,.08,"DT")
3080213
"^DD",8992.7,8992.7,1,0)
DETAILED CONFIG^8992.71^^1;0
"^DD",8992.7,8992.7,2.01,0)
PRINT LAYOUT^K^^2;E1,245^K:$L(X)>245 X D:$D(X) ^DIM
"^DD",8992.7,8992.7,2.01,3)
To replace the default Print Layout enter a new one.  The Ans
"^DD",8992.7,8992.7,2.01,21,0)
^.001^45^45^3080220^^^^
"^DD",8992.7,8992.7,2.01,21,1,0)
The PRINT LAYOUT is a string of characters based on those used for Log4J 
"^DD",8992.7,8992.7,2.01,21,2,0)
to describe the data and order to be output for the log entries.  The 
"^DD",8992.7,8992.7,2.01,21,3,0)
type identifiers begin with % (%% will yield a literal %), are case 
"^DD",8992.7,8992.7,2.01,21,4,0)
sensitive and may have some positioning data before the type identifier.
"^DD",8992.7,8992.7,2.01,21,5,0)
 
"^DD",8992.7,8992.7,2.01,21,6,0)
  %n should be the final entry on the line and indicates the end of the 
"^DD",8992.7,8992.7,2.01,21,7,0)
     line.
"^DD",8992.7,8992.7,2.01,21,8,0)
  %p the priority (FATAL, ERROR, WARN, INFO, or DEBUG) of the log entry.
"^DD",8992.7,8992.7,2.01,21,9,0)
  %t the job number for the current job.
"^DD",8992.7,8992.7,2.01,21,10,0)
  %m the message to be displayed for the call to the logger..
"^DD",8992.7,8992.7,2.01,21,11,0)
  %L the location within the routine of the call to the logger (e.g., 
"^DD",8992.7,8992.7,2.01,21,12,0)
     TAG+3).
"^DD",8992.7,8992.7,2.01,21,13,0)
  %M the TAG entry within which the call to the logger occurs (note this 
"^DD",8992.7,8992.7,2.01,21,14,0)
     is included as part of %L).
"^DD",8992.7,8992.7,2.01,21,15,0)
  %F the name of the routine in which the call to the logger occurs.
"^DD",8992.7,8992.7,2.01,21,16,0)
  %d the date/time of the call to the logger if no format is supplied, the
"^DD",8992.7,8992.7,2.01,21,17,0)
     default format of yyyyMMdd.HHmmss will be used.  The format for date
"^DD",8992.7,8992.7,2.01,21,18,0)
     time is indicated by %d followed by one or more of the following
"^DD",8992.7,8992.7,2.01,21,19,0)
     indicators contained within curly braces { }.
"^DD",8992.7,8992.7,2.01,21,20,0)
 
"^DD",8992.7,8992.7,2.01,21,21,0)
       y  indicates a year digit yy or  yyyy would be the normal for two
"^DD",8992.7,8992.7,2.01,21,22,0)
          year digits or four digits
"^DD",8992.7,8992.7,2.01,21,23,0)
 
"^DD",8992.7,8992.7,2.01,21,24,0)
       M indicates a Month (MM is month digits, MMM is month 
"^DD",8992.7,8992.7,2.01,21,25,0)
         abbreviation and MMMM or more is the month name)
"^DD",8992.7,8992.7,2.01,21,26,0)
       d indicates the day number.
"^DD",8992.7,8992.7,2.01,21,27,0)
       H indicates hours.
"^DD",8992.7,8992.7,2.01,21,28,0)
       m indicates minutes
"^DD",8992.7,8992.7,2.01,21,29,0)
       s indicates seconds
"^DD",8992.7,8992.7,2.01,21,30,0)
 
"^DD",8992.7,8992.7,2.01,21,31,0)
  A hyphen following the % indicates left justified text, a number 
"^DD",8992.7,8992.7,2.01,21,32,0)
between the % and the parameter indicator is used to indicate a minimum 
"^DD",8992.7,8992.7,2.01,21,33,0)
character width for the data.  %-7p will show the PRIORITY in a minimum 
"^DD",8992.7,8992.7,2.01,21,34,0)
width of seven characters, with the text left justified.
"^DD",8992.7,8992.7,2.01,21,35,0)
 
"^DD",8992.7,8992.7,2.01,21,36,0)
Other text, spaces, etc. will be displayed as indicated in the print 
"^DD",8992.7,8992.7,2.01,21,37,0)
layout.
"^DD",8992.7,8992.7,2.01,21,38,0)
 
"^DD",8992.7,8992.7,2.01,21,39,0)
The default PRINT LAYOUT is
"^DD",8992.7,8992.7,2.01,21,40,0)
 
"^DD",8992.7,8992.7,2.01,21,41,0)
%d{yyyyMMdd.HHmmss} %-5p %L %F - %m%n
"^DD",8992.7,8992.7,2.01,21,42,0)
 
"^DD",8992.7,8992.7,2.01,21,43,0)
resulting in
"^DD",8992.7,8992.7,2.01,21,44,0)
 
"^DD",8992.7,8992.7,2.01,21,45,0)
date/time priority(left justified in 5 chars) tag+offset routine - message
"^DD",8992.7,8992.7,2.01,"DT")
3080220
"^DD",8992.7,8992.71,0)
DETAILED CONFIG SUB-FIELD^^.01^1
"^DD",8992.7,8992.71,0,"DT")
3070427
"^DD",8992.7,8992.71,0,"NM","DETAILED CONFIG")

"^DD",8992.7,8992.71,0,"UP")
8992.7
"^DD",8992.7,8992.71,.01,0)
DETAILED CONFIG^WL^^0;1^Q
"^DD",8992.7,8992.71,.01,3)
This field is used to specify detailed configuration data based on the configuration for Log4J.  The entry may be either text or XML.
"^DD",8992.7,8992.71,.01,"DT")
3070427
"^DD",8992.8,8992.8,0)
FIELD^^2^3
"^DD",8992.8,8992.8,0,"DT")
3040701
"^DD",8992.8,8992.8,0,"IX","B",8992.8,.01)

"^DD",8992.8,8992.8,0,"NM","MUNIT TEST GROUP")

"^DD",8992.8,8992.8,0,"VRPK")
XT
"^DD",8992.8,8992.8,.01,0)
NAME^RF^^0;1^K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",8992.8,8992.8,.01,1,0)
^.1
"^DD",8992.8,8992.8,.01,1,1,0)
8992.8^B
"^DD",8992.8,8992.8,.01,1,1,1)
S ^XTV(8992.8,"B",$E(X,1,30),DA)=""
"^DD",8992.8,8992.8,.01,1,1,2)
K ^XTV(8992.8,"B",$E(X,1,30),DA)
"^DD",8992.8,8992.8,.01,3)
NAME MUST BE 3-30 CHARACTERS, NOT NUMERIC OR STARTING WITH PUNCTUATION
"^DD",8992.8,8992.8,1,0)
TEST ROUTINE^8992.81^^1;0
"^DD",8992.8,8992.8,2,0)
DESCRIPTION^8992.82^^2;0
"^DD",8992.8,8992.81,0)
TEST ROUTINE SUB-FIELD^^.01^1
"^DD",8992.8,8992.81,0,"DT")
3031021
"^DD",8992.8,8992.81,0,"IX","B",8992.81,.01)

"^DD",8992.8,8992.81,0,"NM","TEST ROUTINE")

"^DD",8992.8,8992.81,0,"UP")
8992.8
"^DD",8992.8,8992.81,.01,0)
TEST ROUTINE^MF^^0;1^K:$L(X)>8!($L(X)<3) X
"^DD",8992.8,8992.81,.01,1,0)
^.1
"^DD",8992.8,8992.81,.01,1,1,0)
8992.81^B
"^DD",8992.8,8992.81,.01,1,1,1)
S ^XTV(8992.8,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",8992.8,8992.81,.01,1,1,2)
K ^XTV(8992.8,DA(1),1,"B",$E(X,1,30),DA)
"^DD",8992.8,8992.81,.01,3)
This is a routine to be used for the MUnit Test Group.  Answer must be 3-8 characters in length.
"^DD",8992.8,8992.81,.01,"DT")
3031021
"^DD",8992.8,8992.82,0)
DESCRIPTION SUB-FIELD^^.01^1
"^DD",8992.8,8992.82,0,"DT")
3040701
"^DD",8992.8,8992.82,0,"NM","DESCRIPTION")

"^DD",8992.8,8992.82,0,"UP")
8992.8
"^DD",8992.8,8992.82,.01,0)
DESCRIPTION^W^^0;1
"^DD",8992.8,8992.82,.01,21,0)
^^1^1^3040701^
"^DD",8992.8,8992.82,.01,21,1,0)
To hold a discription of what the test covers.
"^DD",8992.8,8992.82,.01,"DT")
3040701
"^DIC",8992.7,8992.7,0)
LOG4M CONFIG^8992.7
"^DIC",8992.7,8992.7,0,"GL")
^XTV(8992.7,
"^DIC",8992.7,"B","LOG4M CONFIG",8992.7)

"^DIC",8992.8,8992.8,0)
MUNIT TEST GROUP^8992.8
"^DIC",8992.8,8992.8,0,"GL")
^XTV(8992.8,
"^DIC",8992.8,"B","MUNIT TEST GROUP",8992.8)

**END**
**END**
